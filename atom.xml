<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>igding的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://igding.github.io/"/>
  <updated>2018-09-04T11:03:52.866Z</updated>
  <id>https://igding.github.io/</id>
  
  <author>
    <name>igding</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Window和Windowmanager</title>
    <link href="https://igding.github.io/2018/09/04/Window%E5%92%8CWindowmanager/"/>
    <id>https://igding.github.io/2018/09/04/Window和Windowmanager/</id>
    <published>2018-09-04T09:13:00.000Z</published>
    <updated>2018-09-04T11:03:52.866Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Window叫做窗口，本质上就是承载view的容器<br>  参考资料 Android艺术探索</p></blockquote><pre><code> * &lt;p&gt;The only existing implementation of this abstract class is * android.view.PhoneWindow, which you should instantiate when needing a Window.  这个抽象类唯一的实现类是phoneWindow，当你需要实例化window的时候。 */public abstract class Window {</code></pre><p>但是phoneWindow是<a href="https://igding.github.io/2018/09/02/Android%E9%9A%90%E8%97%8Fapi%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8/">隐藏类</a>，无法直接调用。</p><p><img src="https://upload-images.jianshu.io/upload_images/3117705-5f6b5edf7bf63169.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>我们的应用层，都是通过WindowManager来对UI进行操作。<br>Windowmanager是一个接口，继承自 ViewManager<br>  ViewManager的三个方法，addView，updateViewLayout，removeView并没有在WindowManager中调用，而是在WindowManagerService通过binder来实现</p><p>然而其底层实际上是通过WindowManagerService。</p><pre><code> final Button floatingButton = new Button(this); floatingButton.setText(&quot;button&quot;); final WindowManager.LayoutParams layoutParams =        new WindowManager.LayoutParams(           WindowManager.LayoutParams.WRAP_CONTENT,           WindowManager.LayoutParams.WRAP_CONTENT,           0, 0,           PixelFormat.TRANSPARENT);   // flag 设置 Window 属性layoutParams.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL           | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE           | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED;   // type 设置 Window 类别（层级）   layoutParams.type = WindowManager.LayoutParams.TYPE_APPLICATION;   //相当于设置原点中心位置   layoutParams.gravity = Gravity.TOP | Gravity.LEFT;   //如果想要设置滚动效果的话 ，只能把原点设置为top和left   //设置top和right或者center都不行   layoutParams.x = 100;   //距离原点x轴的位置大小   layoutParams.y = 300;   //距离原点y轴的位置大小   final WindowManager windowManager = getWindowManager();   windowManager.addView(floatingButton, layoutParams);   floatingButton.setOnTouchListener(new View.OnTouchListener() {       @Override       public boolean onTouch(View v, MotionEvent event) {           Log.i(TAG, &quot;onTouch: &quot;);           int rawX = (int) event.getRawX();           int rawY = (int) event.getRawY();           int startX = 0;           switch (event.getAction()) {               case MotionEvent.ACTION_DOWN:                   startX = (int) event.getX();                   break;               case MotionEvent.ACTION_MOVE:                   if (Math.abs(startX - event.getX()) &gt; ViewConfiguration.get(MainActivity.this).getScaledTouchSlop()) {                       layoutParams.x = rawX;                       layoutParams.y = rawY;                       windowManager.updateViewLayout(floatingButton, layoutParams);                   }           }           return true;       }   });</code></pre><p>同样的 WindowManagerService也是个隐藏类</p><pre><code>/** {@hide} */public class WindowManagerService extends IWindowManager.Stub    implements Watchdog.Monitor, WindowManagerPolicy.WindowManagerFuncs {</code></pre><p>从这里可以看出，WindowManagerService和WindowManager的交互是一个IPC的过程。所有的视图都是通过Window来呈现的。</p><h2 id="2-Window-分类"><a href="#2-Window-分类" class="headerlink" title="2.Window 分类"></a>2.Window 分类</h2><h3 id="2-1-系统window"><a href="#2-1-系统window" class="headerlink" title="2.1 系统window"></a>2.1 系统window</h3><pre><code>Toast 和系统状态栏都是系统 Window。但调用Toast，不需要权限，系统 Window是需要声明权限才能创建的 Window</code></pre><h3 id="2-2-子window"><a href="#2-2-子window" class="headerlink" title="2.2 子window"></a>2.2 子window</h3><pre><code>子Window不能单独存在，它通常依附在父window上需要依附在特定的父 Window 中，如Dialog</code></pre><h3 id="2-3-应用-Window"><a href="#2-3-应用-Window" class="headerlink" title="2.3 应用 Window"></a>2.3 应用 Window</h3><pre><code>例如 Acitivity</code></pre><h2 id="3-Window的添加移除更新的过程"><a href="#3-Window的添加移除更新的过程" class="headerlink" title="3.Window的添加移除更新的过程"></a>3.Window的添加移除更新的过程</h2><h3 id="3-1-Window的添加"><a href="#3-1-Window的添加" class="headerlink" title="3.1 Window的添加"></a>3.1 Window的添加</h3><p>window是需要通过windowmanager来进行操作，而windowmanager的实现类则是windowmanagerimpl。而在windowmanagerimpl的addview的操作，则是在WindowManagerGlobal中进行操作。</p><p>目前也就是需要分析WindowManagerGlobal的addview源码操作。</p><pre><code>//核心代码root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); //view的数组中添加view mViews.add(view); //数组中添加viewrootimpl. mRoots.add(root); //windowmanagerLayoutparam的数组中添加params mParams.add(wparams);  //则实际上是通过viewrootimpl来完成view的更新 root.setView(view, wparams, panelParentView);</code></pre><p>ViewRootImpl的核心代码在于</p><pre><code> // Schedule the first layout -before- adding to the window// manager, to make sure we do the relayout before receiving// any other events from the system.  异步刷新请求 requestLayout();==&gt;scheduleTraversals();   try {        mOrigWindowType = mWindowAttributes.type;        mAttachInfo.mRecomputeGlobalAttributes = true;        collectViewAttributes();        //核心代码        res = mWindowSession.addToDisplay(mWindow, mSeq                        , mWindowAttributes,getHostVisibility(),          mDisplay.getDisplayId(),mAttachInfo.mContentInsets,       mAttachInfo.mStableInsets,mAttachInfo.mOutsets, mInputChannel);</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/3117705-cc9b4ce4400fa9b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="因为是framework层，所以看不到代码"></p><p>这里就需要借助<a href="http://androidxref.com/7.1.2_r36/s?defs=WindowManagerService&amp;project=frameworks" target="_blank" rel="noopener">在线源码阅读</a></p><p><img src="https://upload-images.jianshu.io/upload_images/3117705-18c3d6f10625ac0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>查看到addToDisplay方法的调用</p><p>则是在/frameworks/base/services/core/java/com/android/server/wm/路径下的Session类，通过binder的方式</p><p><img src="https://upload-images.jianshu.io/upload_images/3117705-64d534b1f7f0ae8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>这里 梳理一下整个流程<br>window通过windowmanager来操作。其实现类是<br>WindowmanagerImpl<br>而具体的addView则是在WindowManagerGlobal的addView中</p><p>WindowManagerGlobal的addView内部实际上就是通过ViewrootImpl调用SetView，而setView的核心就是两点</p><ol><li>requestLayout() 异步刷新请求<br>2.Session的addToDisplay()的底层实际上就是WMS与WM的binder交互</li></ol><h3 id="3-2-Window的移除过程"><a href="#3-2-Window的移除过程" class="headerlink" title="3.2 Window的移除过程"></a>3.2 Window的移除过程</h3><pre><code>public void removeView(View view, boolean immediate) {    synchronized (mLock) {        // 找到lockedview的角标        int index = findViewLocked(view, true);        //mRoots是ViewRootImpl的数组，根据角标来获取view        View curView = mRoots.get(index).getView();        //核心代码：移除掉view        removeViewLocked(index, immediate);    }private void removeViewLocked(int index, boolean immediate) {    ViewRootImpl root = mRoots.get(index);    View view = root.getView();    if (view != null) {        InputMethodManager imm = InputMethodManager.getInstance();        if (imm != null) {            imm.windowDismissed(mViews.get(index).getWindowToken());        }    }    //核心代码，也就是说，移除工作还是通过viewrootImpl来完成    boolean deferred = root.die(immediate);    if (view != null) {        view.assignParent(null);        if (deferred) {         //已经被移除的view            mDyingViews.add(view);        }    }} //分析die方法 boolean die(boolean immediate) {    if (immediate &amp;&amp; !mIsInTraversal) {        //核心移除代码        doDie();        return false;    }    if (!mIsDrawing) {        destroyHardwareRenderer();    }    mHandler.sendEmptyMessage(MSG_DIE);    return true;}//分析ViewrootImpl中的doDie方法void doDie() {    checkThread();    synchronized (this) {        if (mRemoved) {            return;        }        mRemoved = true;        if (mAdded) {            //移除的业务逻辑            dispatchDetachedFromWindow();        }        if (mAdded &amp;&amp; !mFirst) {            destroyHardwareRenderer();            if (mView != null) {                int viewVisibility = mView.getVisibility();                boolean viewVisibilityChanged = mViewVisibility != viewVisibility;                if (mWindowAttributesChanged || viewVisibilityChanged) {                                         try {                        if ((relayoutWindow(mWindowAttributes, viewVisibility, false)&amp; WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) {                            mWindowSession.finishDrawing(mWindow);                        }                    } catch (RemoteException e) {                    }                }                //画布释放                mSurface.release();            }        }        mAdded = false;    }    WindowManagerGlobal.getInstance().doRemoveView(this);}</code></pre><p>则实际上还是调用了Session的移除，底层也是wms与wm的binder交互</p><h3 id="3-3-Window的更新"><a href="#3-3-Window的更新" class="headerlink" title="3.3 Window的更新"></a>3.3 Window的更新</h3><p>这个就比较简单了<br>直接看WindowmanagerGlobal源码 updateViewLayout方法</p><pre><code>  public void updateViewLayout(View view, ViewGroup.LayoutParams params) {    final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;   view.setLayoutParams(wparams);   synchronized (mLock) {        int index = findViewLocked(view, true);        ViewRootImpl root = mRoots.get(index);        //实际上就是从layoutparams集合中，移除掉原先的params，新增新的params。        mParams.remove(index);        mParams.add(index, wparams);        //然后通过viewrootImpl去setLayoutparams        //核心代码        root.setLayoutParams(wparams, false);    }}</code></pre><p>viewrootImpl中的setlayoutparams</p><pre><code>void setLayoutParams(WindowManager.LayoutParams attrs, boolean newView) {    synchronized (this) {      //核心代码就这两句，也就是view的绘制过程。       if (newView) {            requestLayout();        }        scheduleTraversals();}</code></pre><p>除了这里之外，还会调用WindowSession来更新window的视图，内部还是通过wms的relayoutWindow()来实现，也是一个ipc的过程</p><h2 id="4-Window的创建过程"><a href="#4-Window的创建过程" class="headerlink" title="4 Window的创建过程"></a>4 Window的创建过程</h2> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">有视图的地方就有window，无论是Activity，dialog，</span><br><span class="line">popupWindow,view不能单独存在，必须要依附在window上。</span><br></pre></td></tr></table></figure><h3 id="4-1-Activity的window创建过程"><a href="#4-1-Activity的window创建过程" class="headerlink" title="4.1 Activity的window创建过程"></a>4.1 Activity的window创建过程</h3><p>Activity的启动过程<br>直接从performLaunchActivity()</p><p>核心代码</p><pre><code> Window window = null;if (r.mPendingRemoveWindow != null &amp;&amp; r.mPreserveWindow) {      window = r.mPendingRemoveWindow;      r.mPendingRemoveWindow = null;      r.mPendingRemoveWindowManager = null;  }    appContext.setOuterContext(activity);  //核心代码    activity.attach(appContext, this, getInstrumentation(), r.token,                    r.ident, app, r.intent, r.activityInfo, title, r.parent,                    r.embeddedID, r.lastNonConfigurationInstances, config,                    r.referrer, r.voiceInteractor, window, r.configCallback);</code></pre><p>进入到Activity的attach方法。</p><pre><code>final void attach(省略参数) {    //phoneWindow是唯一的实例    mWindow = new PhoneWindow(this, window, activityConfigCallback);    //设置各种回调    mWindow.setWindowControllerCallback(this);    mWindow.setCallback(this);    mWindow.setOnWindowDismissedCallback(this);    mWindow.getLayoutInflater().setPrivateFactory(this);    if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) {        mWindow.setSoftInputMode(info.softInputMode);    }    if (info.uiOptions != 0) {        mWindow.setUiOptions(info.uiOptions);    }        mWindow.setContainer(mParent.getWindow());    }    mWindow.setColorMode(info.colorMode);}</code></pre><p>这里我们可以发现，在APP启动的时候，就已经创建了window，并且给window设置了一系列的参数，并将Activity和window相绑定。</p><p>但是这些都只是初始化逻辑，那么Activity的视图和window的视图又是如何相连接的<br>入口：Activity的setContentView()</p><pre><code> public void setContentView(@LayoutRes int layoutResID) {    getWindow().setContentView(layoutResID);    initWindowDecorActionBar();}</code></pre><p>因为window的实现类是属于phoneWindow</p><p>那么这里就需要看PhoneWindow的setContentView方法</p><pre><code>@Overridepublic void setContentView(int layoutResID) {    // 注意：可以在安装窗口的过程中设置FEATURE_CONTENT_TRANSITIONS    // 不要检查特性，当主题属性实例化发生之前    if (mContentParent == null) {        //没有DecorView的话，就初始化一个        installDecor();//核心代码    } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {        mContentParent.removeAllViews();    }    if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) {        final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,                getContext());        transitionTo(newScene);    } else {        //核心代码        mLayoutInflater.inflate(layoutResID, mContentParent);    }    final Callback cb = getCallback();    if (cb != null &amp;&amp; !isDestroyed()) {        //代表content已经改变的callback回调，在Activity中是个空的实现        cb.onContentChanged();    }} private void installDecor() {    mForceDecorInstall = false;    if (mDecor == null) {      //初始化DecorView        mDecor = generateDecor(-1);          //DEcorView设置window        mDecor.setWindow(this);      if (mContentParent == null) {      //初始化layout      mContentParent = generateLayout(mDecor);</code></pre><p>以上步骤则代表，window的初始化，window和Activity的绑定以及DecorView和Content视图的初始化。均在Activity的onCreate中完成</p><p>真正显示的代码，则是在ActivityThread的handleResumeActivity()中进行。</p><pre><code>//首先要调用performResumeActivity()，调用Activity的onResume()ViewManager wm = a.getWindowManager();WindowManager.LayoutParams l = r.window.getAttributes();a.mDecor = decor;ViewRootImpl impl = decor.getViewRootImpl();impl.notifyChildRebuilt();//添加viewwm.addView(decor, l);WindowManager.LayoutParams l = r.window.getAttributes();    if (r.activity.mVisibleFromClient) {        ViewManager wm = a.getWindowManager();        View decor = r.window.getDecorView();        //更新view        wm.updateViewLayout(decor, l);       }     }   if (r.activity.mVisibleFromClient) {        //显示        r.activity.makeVisible();        }      }</code></pre><p>实际上是Activity调用makeVisible方法。</p><pre><code>void makeVisible() {    if (!mWindowAdded) {        ViewManager wm = getWindowManager();        wm.addView(mDecor, getWindow().getAttributes());        mWindowAdded = true;    }    mDecor.setVisibility(View.VISIBLE);}</code></pre><p>整个流程 实际上分三个部分<br>1.数据的初始化和attach部分<br>ActivityThread的performLaunchActivity()==&gt;内部的attach就是绑定Activity和window相互绑定<br>2.视图层部分</p><h3 id="4-2-Dialog的window创建过程"><a href="#4-2-Dialog的window创建过程" class="headerlink" title="4.2 Dialog的window创建过程"></a>4.2 Dialog的window创建过程</h3><p>入口直接从new dialog开始<br>dialog构造中的方法</p><pre><code>mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);//直接在dialog的构造中new phoneWindow，并且设置各种回调final Window w = new PhoneWindow(mContext);mWindow = w;w.setCallback(this);w.setOnWindowDismissedCallback(this);w.setOnWindowSwipeDismissedCallback(() -&gt; {    if (mCancelable) {         cancel();     } }); w.setWindowManager(mWindowManager, null, null); w.setGravity(Gravity.CENTER);</code></pre><p>而setContentView的过程，实际上就是回到了phoneWindow的setContentView。这个过程和Activity的一致，这里就不描述了。<br>由此可以看到，有的手机dialog是有默认的title,而高版本的没有，这里Decorview是根据版本来进行设置的</p><p>当dialog关闭的时候，会走dismissDialog方法，会通过windowmanager来移除DecorView，同样是wms的IPC过程。并且将mDecor置空，并执行onStop()</p><pre><code>void dismissDialog() {        mWindowManager.removeViewImmediate(mDecor);        mDecor = null;        mWindow.closeAllPanels();        onStop();        mShowing = false;        sendDismissMessage();    }}</code></pre><p>应用层的dialog，必须要Activity的context，因为应用token只有Activity拥有。而如果需要系统级的dialog，则需要将window的type，设置系统级，并且给与对应浮窗权限。</p><h3 id="4-3-Toast的window创建过程"><a href="#4-3-Toast的window创建过程" class="headerlink" title="4.3 Toast的window创建过程"></a>4.3 Toast的window创建过程</h3><p>Toast因为有定时取消的功能，所以内部加入了Handler。</p><p>我们一般使用toast的时候都是这样</p><pre><code>Toast.makeText(this, &quot;1&quot;, 1).show();</code></pre><p>那么这里就从makeText作为入口进行分析。</p><pre><code>public static Toast makeText(@NonNull Context context, @Nullable Looper looper,        @NonNull CharSequence text, @Duration int duration) {    //核心代码    Toast result = new Toast(context, looper);   //通过布局加载器，加载一个默认的布局。并且初始化数据。    LayoutInflater inflate = (LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);    View v = inflate.inflate(com.android.internal.R.layout.transient_notification, null);    TextView tv = (TextView)v.findViewById(com.android.internal.R.id.message);    tv.setText(text);    result.mNextView = v;    result.mDuration = duration;    return result;}//Toast构造方法public Toast(@NonNull Context context, @Nullable Looper looper) {    mContext = context;    //核心代码,TN是一个Binder类。    mTN = new TN(context.getPackageName(), looper);    //初始化数据，加载自带的dimen值    mTN.mY = context.getResources().getDimensionPixelSize(            com.android.internal.R.dimen.toast_y_offset);    mTN.mGravity = context.getResources().getInteger(            com.android.internal.R.integer.config_toastDefaultGravity);}  //TN构造方法源码分析TN(String packageName, @Nullable Looper looper) {        final WindowManager.LayoutParams params = mParams;             params.height = WindowManager.LayoutParams.WRAP_CONTENT;        params.width = WindowManager.LayoutParams.WRAP_CONTENT;        mPackageName = packageName;         //params的初始化代码，省略.......        if (looper == null) {            looper = Looper.myLooper();        }        //这里是最关键的处理代码        mHandler = new Handler(looper, null) {            @Override            public void handleMessage(Message msg) {                switch (msg.what) {                    case SHOW: {                        IBinder token = (IBinder) msg.obj;                        handleShow(token);                        break;                    }                    case HIDE: {                        handleHide();                        mNextView = null;                        break;                    }                    case CANCEL: {                        handleHide();                        mNextView = null;                        try {                            getService().cancelToast(mPackageName, TN.this);                        } catch (RemoteException e) {                        }                        break;                    }    } @Override    public void show(IBinder windowToken) {        if (localLOGV) Log.v(TAG, &quot;SHOW: &quot; + this);        mHandler.obtainMessage(SHOW, windowToken).sendToTarget();    }    /**     * schedule handleHide into the right thread     */    @Override    public void hide() {        if (localLOGV) Log.v(TAG, &quot;HIDE: &quot; + this);        mHandler.obtainMessage(HIDE).sendToTarget();    }    public void cancel() {        if (localLOGV) Log.v(TAG, &quot;CANCEL: &quot; + this);        mHandler.obtainMessage(CANCEL).sendToTarget();    }而这个类自身就有sendMessage</code></pre><p>我们再来看看Toast的show方法在做什么</p><pre><code>public void show() {    //很显然Toast的show，是一个IPC的过程。    INotificationManager service = getService();    String pkg = mContext.getOpPackageName();    TN tn = mTN;    tn.mNextView = mNextView;    try {        service.enqueueToast(pkg, tn, mDuration);    } catch (RemoteException e) {    }}//NotificationManagerService的源码分析。//这里是通过一个Toast的queue队列，来处理ToastRecord//从队列里面获取或者回收到队列中。@Overridepublic void enqueueToast(String pkg, ITransientNotification callback, int duration)    {        synchronized (mToastQueue) {            int callingPid = Binder.getCallingPid();            long callingId = Binder.clearCallingIdentity();            try {                ToastRecord record;                int index;              //判断是否是系统toast                if (!isSystemToast) {                    index = indexOfToastPackageLocked(pkg);                } else {                    index = indexOfToastLocked(pkg, callback);                }                if (index &gt;= 0) {                    record = mToastQueue.get(index);                    record.update(duration);                    record.update(callback);                } else {                    Binder token = new Binder();                    mWindowManagerInternal.addWindowToken(token, TYPE_TOAST, DEFAULT_DISPLAY);                    record = new ToastRecord(callingPid, pkg, callback, duration, token);                    mToastQueue.add(record);                    index = mToastQueue.size() - 1;                }                keepProcessAliveIfNeededLocked(callingPid);                if (index == 0) {                    //当Toast添加完之后，就显示toast                    showNextToastLocked();                }            } finally {                Binder.restoreCallingIdentity(callingId);            }        }    }@GuardedBy(&quot;mToastQueue&quot;)void showNextToastLocked() {    ToastRecord record = mToastQueue.get(0);    while (record != null) {         try {            record.callback.show(record.token);            //核心代码            scheduleTimeoutLocked(record);            return;        } catch (RemoteException e) {               int index = mToastQueue.indexOf(record);            if (index &gt;= 0) {                mToastQueue.remove(index);            }            keepProcessAliveIfNeededLocked(record.pid);            if (mToastQueue.size() &gt; 0) {                record = mToastQueue.get(0);            } else {                record = null;            }        }    }} @GuardedBy(&quot;mToastQueue&quot;)private void scheduleTimeoutLocked(ToastRecord r){    mHandler.removeCallbacksAndMessages(r);    Message m = Message.obtain(mHandler, MESSAGE_TIMEOUT, r);    long delay = r.duration == Toast.LENGTH_LONG ? LONG_DELAY : SHORT_DELAY;    //这里就会开始做一个延迟加载。再去进行消息的传递。    mHandler.sendMessageDelayed(m, delay);}</code></pre><p>也就是说，完成一个toast，调用了两种ipc的过程<br>分别是toast.makeText()调用了Toast内部的TN过程<br>还有show方法里面的NotificationManagerService的IPC过程</p><h3 id="4-最后的问题-一个应用中有多少个-Window？"><a href="#4-最后的问题-一个应用中有多少个-Window？" class="headerlink" title="4 最后的问题  一个应用中有多少个 Window？"></a>4 最后的问题  一个应用中有多少个 Window？</h3><p>默认是有一个<br>常规：Activity数量+dialog数量+1</p><p>我们可以从Activity的源码开始分析<br>Activity是属于应用级的window</p><p><img src="https://upload-images.jianshu.io/upload_images/3117705-3726b7afe16e5878.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="因为window是个抽象类，实现类就是phoneWindow"><br>所以这里就代表了 多少个Activity就有多少应用级的window</p><p><img src="https://upload-images.jianshu.io/upload_images/3117705-ca7e2c3b94a89097.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="toast是属于系统window"></p><p><img src="https://upload-images.jianshu.io/upload_images/3117705-82881c702273df0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="PopupWindow和Activity是共用一个window"></p><p><img src="https://upload-images.jianshu.io/upload_images/3117705-dbb3070807abcff4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dialog是属于应用window，说明多少个dialog对应多少个window"></p><p><img src="https://upload-images.jianshu.io/upload_images/3117705-27b149722c876ecd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="有多少dialogFragment也有多少window"></p><p>很明显 dialogfragment是继承自Fragment的，Fragment的context是属于Activity，但是内部是有dialog的</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">很显然，我们不能简单的按照什么Activity，dialog  dialogfragment来算。</span><br><span class="line">因为如果以后Google新建一大堆组件的话，那答案岂不是没个标准了？？</span><br><span class="line"></span><br><span class="line">综上，具体有多少window，这个是要看window到底是属于子window</span><br><span class="line">还是属于系统window还是应用window</span><br><span class="line">应用window的话，创建多少就有多少</span><br><span class="line">系统window就只有一个</span><br><span class="line">子window的话，创建多少就有多少</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Window叫做窗口，本质上就是承载view的容器&lt;br&gt;  参考资料 Android艺术探索&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt; * &amp;lt;p&amp;gt;The only existing implementation of
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android隐藏api如何调用</title>
    <link href="https://igding.github.io/2018/09/02/Android%E9%9A%90%E8%97%8Fapi%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8/"/>
    <id>https://igding.github.io/2018/09/02/Android隐藏api如何调用/</id>
    <published>2018-09-02T09:52:00.000Z</published>
    <updated>2018-09-02T09:52:44.102Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>编译时的jar(sdk/platforms/androidversion/android.jar)属于阉割版，它去掉了带有@hide的类和internal包下的类<br>而运行时，系统会调用android设备中完整版的jar(/system/framework/framework.jar)</p></blockquote><h3 id="1-哪些api不能直接调用？"><a href="#1-哪些api不能直接调用？" class="headerlink" title="1.哪些api不能直接调用？"></a>1.哪些api不能直接调用？</h3><pre><code>1.com.android.internal 包下的 API（internal API） 2.被标记为 @hide 属性的类和方法的隐藏API(hidden API)</code></pre><h3 id="2-Google设置隐藏类和internal包不能调用的原因"><a href="#2-Google设置隐藏类和internal包不能调用的原因" class="headerlink" title="2.Google设置隐藏类和internal包不能调用的原因"></a>2.Google设置隐藏类和internal包不能调用的原因</h3><pre><code>1.api属于内部逻辑，不想对外开发2.可能存在着低版本和高版本之间的兼容性问题，不对外开发3.也有可能是api的接口未确定下来。</code></pre><h3 id="3-如何使用这些api"><a href="#3-如何使用这些api" class="headerlink" title="3.如何使用这些api"></a>3.如何使用这些api</h3><h3 id="3-1-反射-具体调用，略"><a href="#3-1-反射-具体调用，略" class="headerlink" title="3.1.反射(具体调用，略)"></a>3.1.反射(具体调用，略)</h3><h3 id="3-1-1为什么可以通过反射来调用？"><a href="#3-1-1为什么可以通过反射来调用？" class="headerlink" title="3.1.1为什么可以通过反射来调用？"></a>3.1.1为什么可以通过反射来调用？</h3><pre><code>因为编译时，调用的sdk是android.jar，移除了internal API 和 hidden API而运行时它会加载 /system/framework/framework.jar，它没有移除也就是说我们编译时的SDK中不包含这些API，所以无法进行调用当我们利用反射，程序在设备上运行的时候，其实是可以找到对应的方法进行调用的。</code></pre><h3 id="3-2-替换jar包"><a href="#3-2-替换jar包" class="headerlink" title="3.2.替换jar包"></a>3.2.<a href="https://github.com/anggrayudi/android-hidden-api" target="_blank" rel="noopener">替换jar包</a></h3><p><img src="https://upload-images.jianshu.io/upload_images/3117705-752ce8b427cd9291.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="阉割版的jar包"></p><p><img src="https://upload-images.jianshu.io/upload_images/3117705-0363c8cb4e0e4212.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>具体操作，照着GitHub导入依赖即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;编译时的jar(sdk/platforms/androidversion/android.jar)属于阉割版，它去掉了带有@hide的类和internal包下的类&lt;br&gt;而运行时，系统会调用android设备中完整版的jar(/system/fra
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>分类整理layout布局文件</title>
    <link href="https://igding.github.io/2018/08/20/%E5%88%86%E7%B1%BB%E6%95%B4%E7%90%86layout%E5%B8%83%E5%B1%80%E6%96%87%E4%BB%B6/"/>
    <id>https://igding.github.io/2018/08/20/分类整理layout布局文件/</id>
    <published>2018-08-20T15:00:00.000Z</published>
    <updated>2018-08-21T15:04:48.419Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对于强迫症患者来说，一大堆拥挤的xml文件，肯定是让人看的不舒服的，学习到一种有效管理xml的方式，供参考</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/3117705-53d16904281265c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="分类管理"></p><p>其实就是七个步骤</p><ol><li><p>切换Project</p></li><li><p>原有的layout文件都备份到其他文件夹，并删除</p></li><li><p>New ==&gt; directory 创建立一级目录<br> 命名无所谓，但是要和gradle中的src/main/res下的名字保持一致</p></li><li><p>创建多个二级目录，同样需要名字保持一致</p></li><li><p>每个二级目录下，必须都要创建一个layout文件夹</p><pre><code>注意:在AS中创建的话，会出现layouts. fragment.layout的格式，而不是树形结构，建议就在电脑的中手动新建文件夹</code></pre></li><li><p>在gradle中android标签内 加入如下代码</p><pre><code>sourceSets {  main {      res.srcDirs =              [                      &apos;src/main/res/layouts/fragment&apos;,                      &apos;src/main/res/layouts/activity&apos;,                      &apos;src/main/res/layouts/dialog&apos;,                      &apos;src/main/res/layouts/items&apos;,                      &apos;src/main/res/layouts/toolbar&apos;,                      &apos;src/main/res/layouts/nodata&apos;,                      &apos;src/main/res/layouts&apos;,                      &apos;src/main/res&apos;              ]        }  }这里注意    a.命名，可参照我的图来操作。    b.一定要把 src/main/res/layouts  和 src/main/res 写在最后面</code></pre></li><li><p>sync now就可以了。xml的用法和以前是一样的，只不过结构改了而已</p><pre><code>如有报错，请检查以下两点    1.Duplicate file  重复文件    2.每个二级目录下的layout没有创建    file grouping插件是可以自动生成，但是as版本升级之后，貌似有bug    不能用，作者也没维护了</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;对于强迫症患者来说，一大堆拥挤的xml文件，肯定是让人看的不舒服的，学习到一种有效管理xml的方式，供参考&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>序列化和反序列化</title>
    <link href="https://igding.github.io/2018/08/19/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://igding.github.io/2018/08/19/序列化和反序列化/</id>
    <published>2018-08-19T07:42:42.000Z</published>
    <updated>2018-08-19T11:08:14.438Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>序列化 (Serialization)，实际上就是把对象的状态信息转换为可以存储或传输的形式的过程。进行数据传递时，必须要完成对象的序列化<br>运行时的对象状态转换成二进制，然后保存到流或者内存或者通过网络传输给其他端。<br>例如，通过将对象序列化到剪贴板，可在不同的应用程序之间共享对象。</p></blockquote><h3 id="1-Serializable接口"><a href="#1-Serializable接口" class="headerlink" title="1.Serializable接口"></a>1.Serializable接口</h3><h4 id="1-1-用法"><a href="#1-1-用法" class="headerlink" title="1.1 用法"></a>1.1 用法</h4><pre><code>a.直接实现这个接口。b.对象的序列化通过ObjectOutputStream.writeObject完成c.反序列化则是通过ObjectInputStream.readObject完成缺点是，两者不是同一个对象。</code></pre><h4 id="1-2-Serializable的缺点"><a href="#1-2-Serializable的缺点" class="headerlink" title="1.2 Serializable的缺点"></a>1.2 Serializable的缺点</h4><pre><code>整个对象都进行传递，开销很大，序列化和反序列化的过程需要大量的io操作。没必要</code></pre><h4 id="1-3-SerialVersionUID-序列化的标识"><a href="#1-3-SerialVersionUID-序列化的标识" class="headerlink" title="1.3 SerialVersionUID(序列化的标识)"></a>1.3 SerialVersionUID(序列化的标识)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">UID的作用，就相当于一个tag，作为唯一标识，可以写成1L</span><br><span class="line">如果不写这个serialVersionUID(哈希值)，序列化的过程中没什么影响</span><br><span class="line">但是对反序列化readObject时会报错。</span><br><span class="line">eclipse会自动生成，而在as则不会。as的生成顺序</span><br><span class="line">preferences-&gt;Inspections-&gt;</span><br><span class="line">serialization issues-&gt;</span><br><span class="line">Serializable class without &apos;serialVersionUID&apos; 勾上确认就可以</span><br></pre></td></tr></table></figure><h5 id="1-3-1-详细的工作机制："><a href="#1-3-1-详细的工作机制：" class="headerlink" title="1.3.1 详细的工作机制："></a>1.3.1 详细的工作机制：</h5><pre><code>序列化的时候，系统将类的uid写入序列化文件。反序列化时，系统会检测UID，看与当前类的是否一致，一致的话，则    说明序列化的类版本和当前类的版本相同。这个时候就可以成功反序列化。</code></pre><h3 id="2-Android特有的序列化方式。Parcelable"><a href="#2-Android特有的序列化方式。Parcelable" class="headerlink" title="2.Android特有的序列化方式。Parcelable"></a>2.Android特有的序列化方式。Parcelable</h3><p>实现了Parcelable，就完成序列化，并通过intent和binder来传递。</p><pre><code>public class Student implements Parcelable {    String name;    String age;protected Student(Parcel in) {    name = in.readString();    age = in.readString();}//实现序列化@Overridepublic void writeToParcel(Parcel dest, int flags) {    //dest内部包装了可序列化的数据，可以在binder中传递    dest.writeString(name);    dest.writeString(age);}@Overridepublic int describeContents() {    return 0;}//反序列化功能，创建序列化对象和数组。public static final Creator&lt;Student&gt; CREATOR = new Creator&lt;Student&gt;() {    @Override    public Student createFromParcel(Parcel in) {        //in来实现反序列化。        return new Student(in);    }    @Override    public Student[] newArray(int size) {        return new Student[size];    }};}</code></pre><p>例如 Android底层 如intent，bundle，bitmap等，都是实现了序列化<br><img src="https://upload-images.jianshu.io/upload_images/3117705-f4d37e444b8729c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="intent"></p><p><img src="https://upload-images.jianshu.io/upload_images/3117705-0626aa15be9d3823.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="bundle"></p><p><img src="https://upload-images.jianshu.io/upload_images/3117705-43f237bdb492061d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="bitmap"></p><p>同时list和map也可以序列化，前提是其子元素都是可序列化的。</p><h3 id="3-如何抉择"><a href="#3-如何抉择" class="headerlink" title="3. 如何抉择"></a>3. 如何抉择</h3><p>网络中传递对象或者进程中传递，如Activity之间传输数据<br>则用Parcelable更好，其底层是binder通信。</p><p>而作为永久存储对象的话，则还是建议用Serializable<br>因为parcelable只是方便IPC，如果改变任何Parcel中数据的底层实现都可能导致之前的数据不可读取，所以此时还是建议使用Serializable。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;序列化 (Serialization)，实际上就是把对象的状态信息转换为可以存储或传输的形式的过程。进行数据传递时，必须要完成对象的序列化&lt;br&gt;运行时的对象状态转换成二进制，然后保存到流或者内存或者通过网络传输给其他端。&lt;br&gt;例如，通过将对象序
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于联网检测广播中弹窗所引发的思考</title>
    <link href="https://igding.github.io/2018/08/09/%E5%85%B3%E4%BA%8E%E8%81%94%E7%BD%91%E6%A3%80%E6%B5%8B%E5%B9%BF%E6%92%AD%E4%B8%AD%E5%BC%B9%E7%AA%97%E6%89%80%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>https://igding.github.io/2018/08/09/关于联网检测广播中弹窗所引发的思考/</id>
    <published>2018-08-09T07:42:42.000Z</published>
    <updated>2018-08-19T13:38:44.477Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一个单独的知识点，肯定是没多大用，但是以这个点为圆心，深入其原理，并且扩展到其他知识点以及各自的用法区别含义，不断的整理出自己的知识体系，将会非常有用。</p></blockquote><p>BroadCastReceiver中弹出dialog报错，这种现象所涉及到的知识点</p><p><img src="https://upload-images.jianshu.io/upload_images/3117705-4fbb170ffa600e45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="涉及到的知识点"></p><p><img src="https://upload-images.jianshu.io/upload_images/3117705-dc8476b0f7dcd5cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="涉及到的知识点"></p><h2 id="1-广播的工作流程"><a href="#1-广播的工作流程" class="headerlink" title="1.广播的工作流程"></a>1.<a href="https://igding.github.io/2018/08/01/BroadcastReceiver%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/">广播的工作流程</a></h2><h2 id="2-intentFilter匹配规则"><a href="#2-intentFilter匹配规则" class="headerlink" title="2.intentFilter匹配规则"></a>2.<a href="https://igding.github.io/2018/08/05/IntentFilter%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99/">intentFilter匹配规则</a></h2><h2 id="3-联网状态监测的广播中弹出-dialog的报错注意事项"><a href="#3-联网状态监测的广播中弹出-dialog的报错注意事项" class="headerlink" title="3.联网状态监测的广播中弹出 dialog的报错注意事项"></a>3.联网状态监测的广播中弹出 dialog的报错注意事项</h2><p>Android规定大多数的弹窗都要附加在activity之上。如果想要在广播中进行弹窗的话，则必须遵循以下三点<br>a.设置系统级弹窗权限</p><p><code>&lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot; /&gt;</code></p><p>b.在show()之前，要先设置Dialog的类型为TYPE_SYSTEM_ALERT。<br><code>dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);</code></p><p>c.动态注册广播(在baseactivity中注册)</p><h2 id="4-从设计的角度"><a href="#4-从设计的角度" class="headerlink" title="4.从设计的角度"></a>4.从设计的角度</h2><p>为什么现在的APP都不这样设计了<br>例如微信QQ淘宝百度，当用户没有网络时，仅仅只是一个toast，而不显示弹窗提示用户去设置联网。</p><h3 id="4-1-从设计的角度来考虑"><a href="#4-1-从设计的角度来考虑" class="headerlink" title="4.1 从设计的角度来考虑"></a>4.1 从设计的角度来考虑</h3><p>多半是因为 用户习惯问题，因为一般用户看到没有网时，都会下滑手机屏幕，打开WiFi或者数据，而不是点到设置，再进行弹窗。</p><h3 id="4-2-从开发的角度考虑"><a href="#4-2-从开发的角度考虑" class="headerlink" title="4.2 从开发的角度考虑"></a>4.2 从开发的角度考虑</h3><p>部分厂商的”设置wifi”界面的路径不一样，就会存在兼容性问题<br>解决办法：下载顶部activity软件，知道手机的路径后用隐式intent去打开。</p><h2 id="5-关于网络的util"><a href="#5-关于网络的util" class="headerlink" title="5.关于网络的util"></a>5.关于<a href="https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/src/main/java/com/blankj/utilcode/util/NetworkUtils.java" target="_blank" rel="noopener">网络的util</a></h2><p><img src="https://upload-images.jianshu.io/upload_images/3117705-703cdaf28e76cdd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="优化的部分"></p><pre><code>注意事项:    1.这里获取的context基本都是属于application，所以统一在单独的类中进行获取即可    2.如果是activity的context的话，就必须通过传参的形式处理。    3.startActivity时，不要用application的context来进行。</code></pre><h2 id="6-关于Context"><a href="#6-关于Context" class="headerlink" title="6.关于Context"></a>6.关于<a href="https://blog.csdn.net/guolin_blog/article/details/47028975" target="_blank" rel="noopener">Context</a></h2><h3 id="6-1-Context的继承关系"><a href="#6-1-Context的继承关系" class="headerlink" title="6.1 Context的继承关系"></a>6.1 Context的继承关系</h3><p><img src="https://upload-images.jianshu.io/upload_images/3117705-891b1825dfca2cfe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><pre><code>从这里看出来，context只有三种，service，application和activity。Context数量 = Activity数量 + Service数量 + Application(1)</code></pre><h3 id="6-2-Context的应用场景"><a href="#6-2-Context的应用场景" class="headerlink" title="6.2 Context的应用场景"></a>6.2 Context的应用场景</h3><p><img src="https://upload-images.jianshu.io/upload_images/3117705-ae78392b41fe21b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><pre><code>注意事项 1.与UI相关的context，则要用activity的context        2.因为activity的context生命周期和application的生命周期不一样，          Context引用的持有可能造成OOM的问题        3.如果用application去开启activity，会产生一个新的task，不建议</code></pre><h3 id="6-3-使用Application时的注意事项"><a href="#6-3-使用Application时的注意事项" class="headerlink" title="6.3 使用Application时的注意事项"></a>6.3 使用Application时的注意事项</h3><pre><code>Application是单例,全局只有一个(多进程除外)，无需new,系统组件的实例是要由系统来去创建的如果new Application的话，它就只是一个普通的Java对象，不具备任何Context的能力。而且看到很多都在application中自定义一个getInstance，单例模式来得到一个application对象，这一点是完全没有必要的，直接通过context.getApplication就行了</code></pre><p>总结：Android和Java的区别，划分的界限：Android不像Java写一个类和main就可以运行，而是有一个完整的Android工程环境，在这个环境下，要有像Activity、Service、BroadcastReceiver等系统组件，而这些组件并不是像一个普通的Java对象new一下就能创建实例的了，而是要有它们各自的上下文环境，</p><h2 id="7-Dialog的封装"><a href="#7-Dialog的封装" class="headerlink" title="7.Dialog的封装"></a>7.Dialog的封装</h2><p>可以作为参考<br><a href="https://juejin.im/entry/57ecca752e958a0055385815" target="_blank" rel="noopener">https://juejin.im/entry/57ecca752e958a0055385815</a></p><p>当然还有龙哥的baseDialog，还有就是需要把layout文件夹进行拆分，方便去管理xml文件。<br>还有涉及到适配的问题。需要自己弄一套适配utils。<br>以及涉及到<a href="https://www.jianshu.com/p/9dbb03203fbc" target="_blank" rel="noopener">防抖动</a><br>这里的防抖动还会涉及到事件分发以及butterkife的问题。</p><p>具体的业务考虑 还是需要根据自身的项目来进行封装，如果只是基本的布局显示和点击的话，无所谓，但是如果是根据实际需要的话</p><p>Android为什么不能和Java一样，new一个activity直接用？原因：Android和Java不同，Android是属于组件式的管理，必须要有activity和service等组件</p><p>注意事项<br><img src="https://upload-images.jianshu.io/upload_images/3117705-15db2461fdfea3df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="关于context内存泄露的问题"><br>或许可以用软引用，但是可能会造成空指针的问题。对强引用弱引用的理解还是不太深刻，只是停留在表面。如果这样的单例会造成内存泄漏的话，那么常规单例写法为什么不会造成泄露问题？Java里面存在内存泄漏吗？</p><p>用ApplicationContext即可和生命周期保持一致。但是不知道为什么</p><p>在使用context时，有一个标准，只要是和UI有关的，都要用activity作为context。其他的一些操作，Service,Activity,Application等实例都可以，当然，需要注意Context引用的持有，防止内存泄漏。</p><p>2.<a href="https://blog.csdn.net/huachao1001/article/details/51866287" target="_blank" rel="noopener">window和activity之间的关系</a>3.dialog和activity之间的关系，以及生命周期</p><p>3.懒加载的问题<br>4.关于各种utils封装的问题<br>5.关于各种三方库的原理问题<br>6.eventbus的问题<br>7.dialog和popuwindow的区别，如何抉择？以及最新的<a href="https://www.jianshu.com/p/af6499abd5c2" target="_blank" rel="noopener">dialogfragment</a><br>又到底好在哪里？</p><p>1.如果只求进度，不理睬原先留下的坑，就会给自己留坑<br>2.三方库原理说是说搞懂，但是一直都没搞懂</p><p>自己整理的资源库里面，用二维码来放apk，而不是直接放在项目里面。</p><p><a href="http://guosxu.iteye.com/blog/977382" target="_blank" rel="noopener">枚举的基本使用</a></p><p><a href="https://www.jianshu.com/p/7f5a9969be53" target="_blank" rel="noopener">关于状态栏白色底部 黑色文字</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;一个单独的知识点，肯定是没多大用，但是以这个点为圆心，深入其原理，并且扩展到其他知识点以及各自的用法区别含义，不断的整理出自己的知识体系，将会非常有用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;BroadCastReceiver中弹出dialog
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>IntentFilter匹配规则</title>
    <link href="https://igding.github.io/2018/08/05/IntentFilter%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99/"/>
    <id>https://igding.github.io/2018/08/05/IntentFilter匹配规则/</id>
    <published>2018-08-05T07:42:42.000Z</published>
    <updated>2018-08-09T08:47:33.424Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前不久，产品提出一个恶心的需求，微信或者QQ分享九张图片，但是一般的分享平台，只能分享一张，此时该如何解决呢？这也是今天的主讲内容，intent。</p></blockquote><h3 id="1-显示intent，跳转Activity"><a href="#1-显示intent，跳转Activity" class="headerlink" title="1. 显示intent，跳转Activity"></a>1. 显示intent，跳转Activity</h3><h4 id="1-1-本应用内，只需要设置指定Activity名，即可跳转"><a href="#1-1-本应用内，只需要设置指定Activity名，即可跳转" class="headerlink" title="1.1 本应用内，只需要设置指定Activity名，即可跳转"></a>1.1 本应用内，只需要设置指定Activity名，即可跳转</h4><h4 id="1-2-同一个手机内，设置ComponentName和包名类名"><a href="#1-2-同一个手机内，设置ComponentName和包名类名" class="headerlink" title="1.2 同一个手机内，设置ComponentName和包名类名"></a>1.2 同一个手机内，设置ComponentName和包名类名</h4><pre><code>Intent intent = new Intent();ComponentName componentName = new ComponentName(&quot;com.example.handler.myapplication&quot;            &quot;MainActivity&quot;);intent.setComponent(componentName);startActivity(intent);//当然，在这之前用pms判断一下，是否存在该包名。不然报错</code></pre><h3 id="2-隐式intent"><a href="#2-隐式intent" class="headerlink" title="2.隐式intent"></a>2.隐式intent</h3><p>通过intentFilter设置一些过滤信息，如果不匹配，则无法启动。<br>一个Activity可以有多个intentFilter,一个intent，只要能匹配任何一组intent-Filter，就可以成功启动Activity，当然其他的三大组件一样。</p><h4 id="2-1-过滤信息主要分三种"><a href="#2-1-过滤信息主要分三种" class="headerlink" title="2.1 过滤信息主要分三种"></a>2.1 过滤信息主要分三种</h4><h5 id="2-1-1-action"><a href="#2-1-1-action" class="headerlink" title="2.1.1 action"></a>2.1.1 action</h5><h5 id="2-1-2-category"><a href="#2-1-2-category" class="headerlink" title="2.1.2 category"></a>2.1.2 category</h5><h5 id="2-1-3-data"><a href="#2-1-3-data" class="headerlink" title="2.1.3 data"></a>2.1.3 data</h5><h4 id="2-2-唯一需要注意几点"><a href="#2-2-唯一需要注意几点" class="headerlink" title="2.2 唯一需要注意几点"></a>2.2 唯一需要注意几点</h4><pre><code>1. action是必须要写的。data和category可以不写。2. category不写时，系统会默认给Activity设置   android.intent.category.DEFAULT3.当前Activity如果想要被隐式调用  那么必须要在intent-Filter中加上category  并且设置DEFAULT属性</code></pre><h3 id="2-3-data主要分成两部分"><a href="#2-3-data主要分成两部分" class="headerlink" title="2.3 data主要分成两部分"></a>2.3 data主要分成两部分</h3><h4 id="2-3-1-mimeType-媒体类型，如图片，文本，视频-image-jpeg、audio、video"><a href="#2-3-1-mimeType-媒体类型，如图片，文本，视频-image-jpeg、audio、video" class="headerlink" title="2.3.1 mimeType(媒体类型，如图片，文本，视频 image/jpeg、audio、video/*)"></a>2.3.1 mimeType(媒体类型，如图片，文本，视频 image/jpeg、audio、video/*)</h4><h4 id="2-3-2-URI-包含的比较多，略，具体看艺术探索-。"><a href="#2-3-2-URI-包含的比较多，略，具体看艺术探索-。" class="headerlink" title="2.3.2 URI(包含的比较多，略，具体看艺术探索)。"></a>2.3.2 URI(包含的比较多，略，具体看艺术探索)。</h4><h3 id="3-常见例子："><a href="#3-常见例子：" class="headerlink" title="3.常见例子："></a>3.常见例子：</h3><h4 id="3-1-启动页"><a href="#3-1-启动页" class="headerlink" title="3.1 启动页"></a>3.1 启动页</h4><pre><code>&lt;intent-filter&gt;  //代表主入口   &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;   //代表APP是在LAUNCHER桌面，也就是系统应用列表   &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&lt;/intent-filter&gt;</code></pre><h4 id="3-2-打电话"><a href="#3-2-打电话" class="headerlink" title="3.2 打电话"></a>3.2 打电话</h4><pre><code>Intent intent = new Intent();intent.setAction(&quot;android.intent.action.CALL&quot;);//匹配系统自带的action和data规则intent.setData(Uri.parse(&quot;tel:&quot;+ mobile));startActivity(intent);</code></pre><p>总之，无论是哪种intent，只需要两边保持一致即可</p><p>具体的分享多张图，参考这篇<a href="https://www.jianshu.com/p/463b519b74ac" target="_blank" rel="noopener">文章</a>即可</p><p>但是疑问点在于，我用<a href="">adb</a>查看微信和QQ的分享页的Activity类名，和这上面的不一致，具体原因也不明白为什么。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;前不久，产品提出一个恶心的需求，微信或者QQ分享九张图片，但是一般的分享平台，只能分享一张，此时该如何解决呢？这也是今天的主讲内容，intent。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-显示intent，跳转Activity&quot;&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>BroadcastReceiver的工作流程</title>
    <link href="https://igding.github.io/2018/08/01/BroadcastReceiver%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/"/>
    <id>https://igding.github.io/2018/08/01/BroadcastReceiver的工作流程/</id>
    <published>2018-08-01T02:59:42.000Z</published>
    <updated>2018-08-05T15:07:43.584Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-广播的基本使用"><a href="#1-广播的基本使用" class="headerlink" title="1.广播的基本使用"></a>1.广播的基本使用</h2><p>类继承 BroadcastReceiver,onReceive回调中处理业务逻辑<br>      intent.getAction来匹配之前写的action等。</p><pre><code>静态：manifest里面注册，通过intent匹配动态： a. new BroadcastReceiver，      b. new IntentFilter，      c. intentfilter.addAction(&quot;匹配规则&quot;)      d. registerReceiver      e. unregisterReceiver</code></pre><h2 id="2-广播的工作流程"><a href="#2-广播的工作流程" class="headerlink" title="2.广播的工作流程"></a>2.广播的工作流程</h2><h3 id="2-1-广播的注册过程"><a href="#2-1-广播的注册过程" class="headerlink" title="2.1 广播的注册过程"></a>2.1 广播的注册过程</h3><h3 id="2-1-1-静态注册：pms-PackageManagerService-来完成解析和注册，四大组件均是pms来完成解析和注册"><a href="#2-1-1-静态注册：pms-PackageManagerService-来完成解析和注册，四大组件均是pms来完成解析和注册" class="headerlink" title="2.1.1 静态注册：pms(PackageManagerService)来完成解析和注册，四大组件均是pms来完成解析和注册"></a>2.1.1 静态注册：pms(PackageManagerService)来完成解析和注册，四大组件均是pms来完成解析和注册</h3><pre><code>public class PackageManagerService extends IPackageManager.Stub  implements PackageSender {mContext.sendOrderedBroadcastAsUser(verification, verifierUser,                            android.Manifest.permission.PACKAGE_VERIFICATION_AGENT,                            new BroadcastReceiver() {                                @Override                                public void onReceive(Context context, Intent intent) {                                    final Message msg = mHandler                                                .obtainMessage(CHECK_PENDING_VERIFICATION);                                    msg.arg1 = verificationId;                                    mHandler.sendMessageDelayed(msg, getVerificationTimeout());                                }                            }, null, 0, null, null);                    mArgs = null;                }</code></pre><p>实际上底层还是通过binder和handler</p><h3 id="2-1-2-动态注册："><a href="#2-1-2-动态注册：" class="headerlink" title="2.1.2 动态注册："></a>2.1.2 动态注册：</h3><pre><code>//入口是在ContextWrap的registerReceiver中。@Overridepublic Intent registerReceiver(    BroadcastReceiver receiver, IntentFilter filter) {    return mBase.registerReceiver(receiver, filter);}</code></pre><p>具体实现则是在ContextImpl(路径：Android/sdk/sources/android-26/android/app)</p><pre><code>//实际上是进程间通信的过程,broadCastReceiver无法直接跨进程传递，需要通过binder进行传递。而IIntentReceiver则是作为一个中转层private Intent registerReceiverInternal(BroadcastReceiver receiver, int userId,        IntentFilter filter, String broadcastPermission,        Handler scheduler, Context context, int flags) {    IIntentReceiver rd = null;//这里是binder的接口。    if (receiver != null) {        if (mPackageInfo != null &amp;&amp; context != null) {            if (scheduler == null) {                scheduler = mMainThread.getHandler();            }            rd = mPackageInfo.getReceiverDispatcher(    //通过广播和context和handler和Instrumentation的转换，获取到iIntentReceiver，取出rd的方法                receiver, context, scheduler,                mMainThread.getInstrumentation(), true);        } else {            if (scheduler == null) {                scheduler = mMainThread.getHandler();            }            rd = new LoadedApk.ReceiverDispatcher(          //主要的存放的方法，intentReceiver的具体实现如下图                              receiver, context, scheduler, null, true).getIIntentReceiver();        }    }    try {        final Intent intent =        //核心注册代码,activityManager得到服务        //实际上是在ActivityManagerService中调用registerReceiver              ActivityManager.getService().registerReceiver(              mMainThread.getApplicationThread(),               mBasePackageName, rd, filter,              broadcastPermission, userId, flags);        if (intent != null) {            intent.setExtrasClassLoader(getClassLoader());            intent.prepareToEnterProcess();        }        return intent;    } catch (RemoteException e) {        throw e.rethrowFromSystemServer();    }}public IIntentReceiver getReceiverDispatcher(BroadcastReceiver r,        Context context, Handler handler,        Instrumentation instrumentation, boolean registered) {    synchronized (mReceivers) {        LoadedApk.ReceiverDispatcher rd = null;        ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt; map = null;//通过键值对的形式去存context和BroadCastReceiver。        if (registered) {            map = mReceivers.get(context);            if (map != null) {                rd = map.get(r);            }        }        if (rd == null) {            rd = new ReceiverDispatcher(r, context, handler,                    instrumentation, registered);            if (registered) {                if (map == null) {                    map = new ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt;();                    mReceivers.put(context, map);                }                map.put(r, rd);            }        } else {            rd.validate(context, handler);        }        rd.mForgotten = false;        return rd.getIIntentReceiver();    }}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/3117705-ca5281f81ae47e8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="intentReceiver的具体实现"></p><p>真正的注册代码核心(AMS中的registerReceiver中)<br>最终将远程的innerReceiver对象以及IntentFilter对象存储起来</p><pre><code>mRegisteredReceivers.put(receiver.asBinder(), rl);BroadcastFilter bf = new BroadcastFilter(filter, rl, callerPackage,                permission, callingUid, userId, instantApp, visibleToInstantApps);rl.add(bf);mReceiverResolver.addFilter(bf);</code></pre><p>也就是说，动态注册的过程如下：<br>Activity的registerReceiver==&gt;<br>ContextWrap的registerReceiver==&gt;<br>ContextImpl的registerReceiverInternal()==&gt;<br>LoadedApk的getReceiverDispatcher()获取IIntentReceiver==&gt;<br>ActivityManager的registerReceiver。</p><h3 id="2-2-广播发送和接收的过程"><a href="#2-2-广播发送和接收的过程" class="headerlink" title="2.2 广播发送和接收的过程"></a>2.2 广播发送和接收的过程</h3><h3 id="2-2-1-发送"><a href="#2-2-1-发送" class="headerlink" title="2.2.1 发送"></a>2.2.1 发送</h3><p>依然是从ContextWrapper的sendBroadcast开始，实现为ContextImp的sendBroadcast。</p><pre><code>@Overridepublic void sendBroadcast(Intent intent) {    warnIfCallingFromSystemProcess();    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());    try {        intent.prepareToLeaveProcess(this);      //异步向ams发送广播        ActivityManager.getService().broadcastIntent(                mMainThread.getApplicationThread(), intent, resolvedType, null,                Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false,                getUserId());    } catch (RemoteException e) {        throw e.rethrowFromSystemServer();    }}</code></pre><p>AMS发送广播代码</p><pre><code> public final int broadcastIntent(IApplicationThread caller,        Intent intent, String resolvedType, IIntentReceiver resultTo,        int resultCode, String resultData, Bundle resultExtras,        String[] requiredPermissions, int appOp, Bundle bOptions,        boolean serialized, boolean sticky, int userId) {    enforceNotIsolatedCaller(&quot;broadcastIntent&quot;);    synchronized(this) {        intent = verifyBroadcastLocked(intent);        final ProcessRecord callerApp = getRecordForAppLocked(caller);        final int callingPid = Binder.getCallingPid();        final int callingUid = Binder.getCallingUid();        final long origId = Binder.clearCallingIdentity();        //核心代码                //广播默认不发送给已经停止的应用        //intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);        int res = broadcastIntentLocked(callerApp,                callerApp != null ? callerApp.info.packageName : null,                intent, resolvedType, resultTo, resultCode, resultData, resultExtras,                requiredPermissions, appOp, bOptions, serialized, sticky,                callingPid, callingUid, userId);        Binder.restoreCallingIdentity(origId);        return res;    }}final int broadcastIntentLocked() {     final BroadcastQueue queue = broadcastQueueForIntent(intent);  BroadcastRecord r = new BroadcastRecord();        final boolean replaced = replacePending                &amp;&amp; (queue.replaceParallelBroadcastLocked(r) != null);          if (!replaced) {            //排序            queue.enqueueParallelBroadcastLocked(r);            //发送过程            queue.scheduleBroadcastsLocked();        }        registeredReceivers = null;        NR = 0;    }</code></pre><p>BroadCastQueue的scheduleBroadcastsLocked方法</p><pre><code>public void scheduleBroadcastsLocked() {    //Set when we current have a BROADCAST_INTENT_MSG in flight    if (mBroadcastsScheduled) {        return;    }//通过handler发送一个Broadcast_intent_msg            mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this));    mBroadcastsScheduled = true;} @Override    public void handleMessage(Message msg) {        switch (msg.what) {            case BROADCAST_INTENT_MSG: {                if (DEBUG_BROADCAST) Slog.v(                        TAG_BROADCAST, &quot;Received BROADCAST_INTENT_MSG&quot;);                processNextBroadcast(true);            } break;final void processNextBroadcast(boolean fromMsg) {        while (mParallelBroadcasts.size() &gt; 0) {            r = mParallelBroadcasts.remove(0);            r.dispatchTime = SystemClock.uptimeMillis();            r.dispatchClockTime = System.currentTimeMillis();            if (Trace.isTagEnabled(Trace.TRACE_TAG_ACTIVITY_MANAGER)) {                Trace.asyncTraceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER,                    createBroadcastTraceTitle(r, BroadcastRecord.DELIVERY_PENDING),                    System.identityHashCode(r));                Trace.asyncTraceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,                    createBroadcastTraceTitle(r, BroadcastRecord.DELIVERY_DELIVERED),                    System.identityHashCode(r));            }            final int N = r.receivers.size();            for (int i=0; i&lt;N; i++) {                Object target = r.receivers.get(i);                deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, false, i);            }            addBroadcastToHistoryLocked(r);        }}</code></pre><p>deliverToRegisteredReceiverLocked()内部调performReceiveLocked()方法完成具体的发送。</p><p>也就是说 整个流程为：<br>ContextWrapper的sendBroadcast()==&gt;<br>ContextImp的sendBroadcast()==&gt;<br>AMS的broadcastIntent()==&gt;<br>AMS的broadcastIntentLocked==&gt;<br>BroadCastQueue的scheduleBroadcastsLocked()==&gt;<br>processNextBroadcast()==&gt;<br>deliverToRegisteredReceiverLocked()==&gt;<br>performReceiveLocked()==&gt;<br>scheduleRegisteredReceiver==&gt;<br>ApplicationThread(ActivityThread的内部类)==&gt;</p><pre><code>//ActivityThread的scheduleRegisteredReceiver，则是 public void scheduleRegisteredReceiver(IIntentReceiver receiver, Intent intent,            int resultCode, String dataStr, Bundle extras, boolean ordered,            boolean sticky, int sendingUser, int processState) throws RemoteException {        updateProcessState(processState, false);        receiver.performReceive(intent, resultCode, dataStr, extras, ordered,                sticky, sendingUser);      //内部则是LoadApk的ReceiverDispatcher类的performReceive方法    }</code></pre><p>而performReceive内部则是调用</p><pre><code>ClassLoader cl = mReceiver.getClass().getClassLoader();intent.setExtrasClassLoader(cl);intent.prepareToEnterProcess();setExtrasClassLoader(cl);receiver.setPendingResult(this);receiver.onReceive(mContext, intent);</code></pre><p>完成整个广播的注册</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-广播的基本使用&quot;&gt;&lt;a href=&quot;#1-广播的基本使用&quot; class=&quot;headerlink&quot; title=&quot;1.广播的基本使用&quot;&gt;&lt;/a&gt;1.广播的基本使用&lt;/h2&gt;&lt;p&gt;类继承 BroadcastReceiver,onReceive回调中处理业务逻辑&lt;b
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>事件分发源码分析</title>
    <link href="https://igding.github.io/2018/07/09/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://igding.github.io/2018/07/09/事件分发源码分析/</id>
    <published>2018-07-08T17:10:42.000Z</published>
    <updated>2018-07-08T17:09:54.804Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对事件分发还不太熟悉，且看完博客还一头雾水的朋友，不妨从面试题下手，带着问题去看源码，再由点到面，辅以xmind和流程图，看能否得以突破。</p></blockquote><p><a href="https://blog.csdn.net/guolin_blog/article/details/9097463" target="_blank" rel="noopener">参考链接</a><br><a href="https://blog.csdn.net/guolin_blog/article/details/9153747#commentsedit" target="_blank" rel="noopener">参考链接</a></p><h2 id="面试题："><a href="#面试题：" class="headerlink" title="面试题："></a>面试题：</h2><h3 id="1-view和viewgroup的事件分发？-事件分发的原理"><a href="#1-view和viewgroup的事件分发？-事件分发的原理" class="headerlink" title="1.view和viewgroup的事件分发？(事件分发的原理)"></a>1.view和viewgroup的事件分发？(事件分发的原理)</h3><p>流程如下</p><p><img src="https://upload-images.jianshu.io/upload_images/3117705-42412c178034e855.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="2-onTouch和onClick冲突问题？"><a href="#2-onTouch和onClick冲突问题？" class="headerlink" title="2.onTouch和onClick冲突问题？"></a>2.onTouch和onClick冲突问题？</h3><p>onTouch和onClick冲突的原因是因为，onTouch设置为true，onClick就不会执行。详细案例和源码分析如下。</p><h4 id="2-1案例："><a href="#2-1案例：" class="headerlink" title="2.1案例："></a>2.1案例：</h4><pre><code>button.setOnTouchListener(this);button.setOnClickListener(this); @Override   public void onClick(View v) {    Log.i(TAG, &quot;onClick: &quot;);}  @Override    public boolean onTouch(View v, MotionEvent event) {      Log.i(TAG, &quot;onTouch: &quot;);    //button.performClick();假设加入这个，即便是写true，也会触发onclick.     return true;//关键是这里，如果设置为true则onclick不打印，设置为false，onclick就打印 }</code></pre><h4 id="2-2源码分析："><a href="#2-2源码分析：" class="headerlink" title="2.2源码分析："></a>2.2源码分析：</h4><blockquote><p>用户触摸屏幕时，将产生Touch事件，Touch事件的相关细节(包括触摸位置，时间等，)而封装的对象，不是Java来做的，而是工作activity的驱动来做的，驱动做完之后，触摸到屏幕时，第一时间会调用到activity的dispatchTouchEvent()，</p></blockquote><p>起点则为Activity的dispatchTouchEvent()</p><pre><code>//Activity类 public boolean dispatchTouchEvent(MotionEvent ev) {    if (ev.getAction() == MotionEvent.ACTION_DOWN) {//为down时触发        onUserInteraction();//作用：实现屏保功能 //当此activity在栈顶时，触屏点击按home，back，menu键等都会触发此方法    }    if (getWindow().superDispatchTouchEvent(ev)) {//PhoneWindow的superDispatchTouchEvent()着重分析。        return true;    }    return onTouchEvent(ev);}//PhoneWindow类@Overridepublic boolean superDispatchTouchEvent(MotionEvent event) {    return mDecor.superDispatchTouchEvent(event);//这里是DecorView}//DecorViewpublic boolean superDispatchTouchEvent(MotionEvent event) {    return super.dispatchTouchEvent(event);  //ViewGroup的dispatchTouchEvent()}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">流程:</span><br><span class="line">起点:底层驱动</span><br><span class="line">==&gt;Activity的dispatchTouchEvent()</span><br><span class="line">==&gt;PhoneWindow的superDispatchTouchEvent()</span><br><span class="line">==&gt;DecorView的superDispatchTouchEvent()</span><br><span class="line">==&gt;ViewGroup的superDispatchTouchEvent()(核心分发)</span><br></pre></td></tr></table></figure><p><a href="https://www.zhihu.com/question/46229570" target="_blank" rel="noopener">vysor实现原理</a></p><pre><code> ViewGroup的DispatchTouchEvent() //触摸屏幕 不一定是用手指去按手机屏幕，也有可能是通过vysor等辅助功能来触摸//而ViewGroup的DispatchTouchEvent()里面 前几段代码的判断。 //则是专门针对vysor等辅助功能软件进行判断//是手指亲自点击 还是用辅助功能点击//涉及到的就不是Java层的了，而是驱动层if (mInputEventConsistencyVerifier != null) {     mInputEventConsistencyVerifier.onTouchEvent(ev, 1);}//Accessibility就是在判断，是否是辅助功能。if (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) {        ev.setTargetAccessibilityFocus(false);}boolean handled = false;//方法最终返回的就是handled.if (onFilterTouchEventForSecurity(ev)) {    boolean handled = false;//方法最终返回的就是handled.    if (onFilterTouchEventForSecurity(ev)) {//过滤，是否拦截，由requestDisallowInterceptTouchEvent()给flgs赋值。从而决定是true还是false      //下面的判断操作 总体是三个部分           //1. 是否是第一次按下的操作，是的话，重启touch状态，touch是针对单指操作        if (actionMasked == MotionEvent.ACTION_DOWN) {            cancelAndClearTouchTargets(ev);//清理touch的target            resetTouchState();//重置状态        }        // 2.是否进行拦截         final boolean intercepted;     if (!disallowIntercept) {    //disallowIntercept这个值决定了 拦截还是不拦截,而赋值操作，则是在requestDisallowInterceptTouchEvent(）进行赋值    //只有viewgroup才可以拦截，view是没有拦截的。view只有分发和处理    intercepted = onInterceptTouchEvent(ev); //是否取消操作，取消就为true，默认是为false，代表手指没有到屏幕外面   final boolean canceled = resetCancelNextUpFlag(this)   if (!canceled &amp;&amp; !intercepted) {//第一次触发，实际上在这里，默认都是false，因为手指没有到屏幕外面，所以canceled为false，默认没有被拦截，也为false。实际上是进入到这里           final int childrenCount = mChildrenCount;            if (newTouchTarget == null &amp;&amp; childrenCount != 0) {             //3.以下则是属于对多控件，对子view按照层级进行排列              final float x = ev.getX(actionIndex);              final float y = ev.getY(actionIndex);                 final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();//这里则是将子view按照层级来保存              final boolean customOrder = preorderedList == null                            &amp;&amp; isChildrenDrawingOrderEnabled();              final View[] children = mChildren;              for (int i = childrenCount - 1; i &gt;= 0; i--) {                  //倒序遍历，获取子控件                  //省略部分业务代码(提取当前的view和按下时间以及坐标等              )  if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {  //这里的dispatchTransformedTouchEvent才是核心代码。内部分发给view的dispatchTouchEvent()    return handled;}</code></pre><p>dispatchTransformedTouchEvent方法 源码分析：</p><pre><code>private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,                                              View child, int desiredPointerIdBits) {    final boolean handled;    final int oldAction = event.getAction();    if (cancel || oldAction == MotionEvent.ACTION_CANCEL) {        event.setAction(MotionEvent.ACTION_CANCEL);        if (child == null) {            handled = super.dispatchTouchEvent(event);        } else {            handled = child.dispatchTouchEvent(event);//因为child不为空，则走到这里，child实际上就是view。        }        event.setAction(oldAction);        return handled;    }</code></pre><p>也就是说，从现在为止，调用顺序则为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">流程:</span><br><span class="line">起点:底层驱动</span><br><span class="line">==&gt;Activity的dispatchTouchEvent()</span><br><span class="line">==&gt;PhoneWindow的superDispatchTouchEvent()</span><br><span class="line">==&gt;DecorView的superDispatchTouchEvent()</span><br><span class="line">==&gt;ViewGroup的superDispatchTouchEvent()(核心分发)</span><br><span class="line">==&gt;View的dispatchTouchEvent()(核心分发)</span><br></pre></td></tr></table></figure></p><p>View的dispatchTouchEvent()的部分重点源码：</p><pre><code>  if (li != null  &amp;&amp; li.mOnTouchListener != null      &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED//所有控件默认都是ENABLED      &amp;&amp; li.mOnTouchListener.onTouch(this, event)) {      //主要看view调用的onTouch为true还是false      result = true;    }  if (!result &amp;&amp; onTouchEvent(event)) {            result = true;  }//关键是这里是设置true还是false。如果是false，则会走result=true，到！result时，就不会执行ontouchEvent()方法，反之就会走onTouchEvent,不执行OntouchEvent，则不会执行其中的performClick()，就不会执行onclick,所以onClick事件是不执行的。从这里的源码，则可以回答刚才的现象，为什么设置false就会执行onTouchEvent，设置true则不会执行。</code></pre><p>当然 核心点就是performClick()方法，如果在onTouchListener中，直接用view去调用performClick()，那么即便onTouchListener返回true，onclick也会执行。</p><h3 id="3-onClick和onLongClick事件能同事发生吗？"><a href="#3-onClick和onLongClick事件能同事发生吗？" class="headerlink" title="3.onClick和onLongClick事件能同事发生吗？"></a>3.onClick和onLongClick事件能同事发生吗？</h3><p>案例代码：</p><p>MainActivity的代码</p><pre><code>    View viewById = findViewById(R.id.myview);    viewById.setOnTouchListener(this);    viewById.setOnClickListener(this);    viewById.setOnLongClickListener(this);@Overridepublic void onClick(View v) {    Log.i(TAG, &quot;onClick: &quot;);}@Overridepublic boolean onLongClick(View v) {    Log.i(TAG, &quot;onLongClick: &quot;);    return false;}@Overridepublic boolean onTouch(View v, MotionEvent event) {    Log.i(TAG, &quot;onTouch: &quot;);    return false;}</code></pre><p>  自定义view的代码</p><pre><code>private static final String TAG = MeView.class.getSimpleName();public MeView(Context context) {    super(context);}public MeView(Context context, @Nullable AttributeSet attrs) {    super(context, attrs);}public MeView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {    super(context, attrs, defStyleAttr);}@Overridepublic boolean dispatchTouchEvent(MotionEvent event) {    Log.i(TAG, &quot;我下发任务了 dispatchTouchEvent :&quot;);    return super.dispatchTouchEvent(event);}@Overridepublic boolean onTouchEvent(MotionEvent event) {    Log.i(TAG, &quot;我处理任务 onTouchEvent :&quot;);    return super.onTouchEvent(event);}</code></pre><p>可以同时发生，只要onLongClick设置为false就可以同时发生，设置为true的话，onClick就不会同时发生。</p><p><img src="https://upload-images.jianshu.io/upload_images/3117705-205574126eff3e33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>通过这个打log来看<br>onLongClick应该是在onTouchEvent()中的down时执行的<br>onClick应该是在onTouchEvent()中的up时执行的</p><p>onTouchEvent()源码分析：<br>分别针对down和up的情况进行分析。</p><pre><code>//找到up的主要源码case MotionEvent.ACTION_UP:    if (!post(mPerformClick)) {          performClick();       }public boolean performClick() {    final boolean result;    final ListenerInfo li = mListenerInfo;    if (li != null &amp;&amp; li.mOnClickListener != null) {        playSoundEffect(SoundEffectConstants.CLICK);        li.mOnClickListener.onClick(this);//重点代码        result = true;    } else {        result = false;    }    return result;}// 找到down的主要源码。 case MotionEvent.ACTION_DOWN:        if (!clickable) {             checkForLongClick(0, x, y);             break;        }</code></pre><p>当然，这其中还有很多流程性的原理。例如 postDelay()方法和removeLongClick()方法</p><pre><code>结论 ：1.从down到up，100毫秒内是点击事件 onclick,          超过500毫秒则是长按事件，onLongClick() 2.move时，未离开控件，则将onclick和onLongClick()移除掉</code></pre><p>关键代码</p><pre><code>if (((viewFlags &amp; CLICKABLE) == CLICKABLE ||          (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) {    //这里只截取部分onTouchEvent()代码    switch (event.getAction()) {          case MotionEvent.ACTION_UP:             break；           case MotionEvent.ACTION_DOWN:                break;          case MotionEvent.ACTION_CANCEL:              break;          case MotionEvent.ACTION_MOVE:              break;      }      return true;  }    return false;  }  </code></pre><p>只要是进入到down move up事件，onTouchEvent()return就为true，否则为false。</p><p>也就是说<br><img src="https://upload-images.jianshu.io/upload_images/3117705-5ff4fe4520323452.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>down move up，任意一个return为true，下面就会执行，如果为false，则不会执行。</p><p>调用默认的super的话，因为符合CLICKABLE，所以是可以执行。<br>如果是继承imageview，则不会执行onTouchEvent()，因为imageview默认是不可点击的，必须要设置点击属性才可以</p><p>上面只是分析了viewgroup的dispatchTouchEvent和view的dispatchTouchEvent，，那么viewgroup的流程还会继续走，事件则会自己消耗掉。</p><pre><code>if (mFirstTouchTarget == null) {  //如果view的dispatchTouchEvent为false，则mFirstTouchTarget为空   handled = dispatchTransformedTouchEvent(ev, canceled, null,TouchTarget.ALL_POINTER_IDS);  //事件会自己消费掉        } </code></pre><p>核心点在于：</p><h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a><a href="https://www.cnblogs.com/java-my-life/archive/2012/05/28/2516865.html" target="_blank" rel="noopener">责任链模式</a></h3><h3 id="事件分发uml流程图"><a href="#事件分发uml流程图" class="headerlink" title="事件分发uml流程图"></a><a href="https://pan.baidu.com/s/13cscBGRFwa9aH36nApg9qw" target="_blank" rel="noopener">事件分发uml流程图</a></h3><p><img src="https://upload-images.jianshu.io/upload_images/3117705-13bac41fb10d5f6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="事件分发的整体流程"></p><h3 id="实际案例bug"><a href="#实际案例bug" class="headerlink" title="实际案例bug"></a>实际案例bug</h3><p>典型案例：</p><p>1.关于popupwindow的bug。<br><a href="https://blog.csdn.net/qq402164452/article/details/53353798" target="_blank" rel="noopener">https://blog.csdn.net/qq402164452/article/details/53353798</a><br>2.<a href="https://blog.csdn.net/Dota_wy/article/details/77451011" target="_blank" rel="noopener">https://blog.csdn.net/Dota_wy/article/details/77451011</a></p><p>当然 这里还要结合实际的滑动冲突的bug，才能真正理解</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;对事件分发还不太熟悉，且看完博客还一头雾水的朋友，不妨从面试题下手，带着问题去看源码，再由点到面，辅以xmind和流程图，看能否得以突破。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/gu
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Mac使用技巧</title>
    <link href="https://igding.github.io/2018/07/08/Mac%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>https://igding.github.io/2018/07/08/Mac使用技巧/</id>
    <published>2018-07-07T19:26:42.000Z</published>
    <updated>2018-08-05T14:58:23.272Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>用Mac已经好几个月了，之前想过整理出一篇博客，但是又觉得没什么必要。随后接连有几个朋友新入手了Mac，貌似即便是官方教学和其他博客来折腾，一方面是时间成本，另外一方面也是会有很多细节和技巧部分讲的不是太清楚，再就是和他们的交流中也的确会弥补自身的一些不足。故此决定还是写一篇较好。仅供参考，欢迎交流</p></blockquote><h2 id="首先"><a href="#首先" class="headerlink" title="首先"></a>首先</h2><p>不妨花个十来分钟看一下<a href="https://support.apple.com/zh-cn/explore/new-to-mac" target="_blank" rel="noopener">官方教学</a> </p><p>推荐书籍 :《Android神兵利器》</p><pre><code>即便不是Android开发人员，也有部分内容可供参考。</code></pre><h2 id="其次"><a href="#其次" class="headerlink" title="其次"></a>其次</h2><p>不推荐买鼠标键盘，因为熟悉了<a href="https://support.apple.com/zh-cn/HT201236" target="_blank" rel="noopener">足够多的快捷键</a>和<a href="https://support.apple.com/zh-cn/HT204895" target="_blank" rel="noopener">触摸板的功能</a>的话，就会觉得鼠标键盘都是多余的，最多买个支架和贴膜和电脑包。<br><img src="https://upload-images.jianshu.io/upload_images/3117705-1844c756d2155c13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="支架"></p><p>屏幕，可以用这个代替(多桌面切换)<br><img src="https://upload-images.jianshu.io/upload_images/3117705-4e9ff697205f8930.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>键盘膜和触摸板的膜，会影响打字手感和触摸板灵活度，不建议。<br>大一点的触摸板，感觉也不太需要(职业习惯，工作时双手不离开键盘)。</p><p>如果你希望面对面互传软件，可以用AirDrop，无需安装包，传完即可用<br><img src="https://upload-images.jianshu.io/upload_images/3117705-baa0cf00f24ad10a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="操作流程: 点击Finder，找到AirDrop，找到对应的人，传输接收安装"></p><h2 id="常用软件推荐："><a href="#常用软件推荐：" class="headerlink" title="常用软件推荐："></a>常用软件推荐：</h2><p>1.自带的文本编辑器换成<a href="https://www.sublimetext.com/3" target="_blank" rel="noopener">Sublime Text</a>,想要用MarkDown格式，则推荐<a href="https://typora.io/" target="_blank" rel="noopener">typroa</a><br>2.浏览器 建议换成Google，火狐等。<br>3.自带的终端换成iTerm或者oh my zsh ,homebrew<br>4.软件Snap<br>a.功能：通过快捷键开启导航栏上的软件(类似于window中的win+数字键)<br>b.优点：想打开某些常用软件，一个快捷键就够了<br>c.缺点：可能与其他软件快捷键冲突(如遇上述情况，请自行调整)<br>d.安装过程：<br><img src="https://upload-images.jianshu.io/upload_images/3117705-8634f6aa57150acd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.搜索和安装"></p><p><img src="https://upload-images.jianshu.io/upload_images/3117705-7a657d8536fd5848.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.打开后设置"></p><p><img src="https://upload-images.jianshu.io/upload_images/3117705-e2286e0da7be3d35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.如图进行配置"></p><p><img src="https://upload-images.jianshu.io/upload_images/3117705-7f194494c4a34bdf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.将系统默认快捷方式从Dock移除，换成常用软件，按照个人习惯调整软件摆放顺序"></p><p><img src="https://upload-images.jianshu.io/upload_images/3117705-bb02b78b6b95143e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5"></p><p>e.使用方法：command+对应数字键<br>f.注意事项：finder无法移除，且从 ~键代表finder 开始计算顺序</p><p><img src="https://upload-images.jianshu.io/upload_images/3117705-aedb7366e6c9015f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="xmind，注册码自行查阅"></p><p>5.<a href="https://www.alfredapp.com/" target="_blank" rel="noopener">Alfred3，快速开启常用网页链接</a> </p><p><img src="https://upload-images.jianshu.io/upload_images/3117705-9fd613f1a69c2a23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.安装完后，点击"></p><p><img src="https://upload-images.jianshu.io/upload_images/3117705-56147de6b276d2c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.操作步骤"></p><p><img src="https://upload-images.jianshu.io/upload_images/3117705-548df9c0b047e115.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.配置你常用的网页地址，并保存"></p><p>Alfred使用方式：alt/option+spec(空格)，输入你刚才填的keyword，回车即可</p><p><img src="https://upload-images.jianshu.io/upload_images/3117705-c2c936e1ea6a52ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="解压软件，随便来个就行，Mac貌似没有"></p><pre><code>不需要什么清理软件</code></pre><h2 id="常用的快捷键"><a href="#常用的快捷键" class="headerlink" title="常用的快捷键"></a>常用的快捷键</h2><p>1.command+空格(搜索文件)<br>2.Command-Q退出应用<br>3.alt+command+esc 强退应用<br>4.enter/return 修改文件名<br>5.control+关机键 关机/重启<br>6.Command-M 缩小当前窗口<br>7.在finder中 command+shift+f 输入指定路径<br>8.查找文件路径<br><img src="https://upload-images.jianshu.io/upload_images/3117705-66f57c75b713fb6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/3117705-2b0ccacfb98f4c92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查找软件路径或者终端输入which+文件名也可以"></p><p>9.还有比较关键的就是这个<a href="https://support.apple.com/zh-cn/HT204895" target="_blank" rel="noopener">触摸板的功能</a></p><p>10.关闭单个网页页面 或者单个文本编辑 快捷键 command+w,切换网页页面 快捷键alt+command+左右 网页前进或者回退 command+左右</p><h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><p>1.window下载的安装包 尾缀是exe，而Mac的是dmg</p><p>2.打开/关闭 隐藏文件夹</p><pre><code>在端口输入以下两行代码(true换成false就是隐藏了)defaults write com.apple.finder AppleShowAllFiles -bool trueKillAll Finder</code></pre><p>3.Linux常用命令也需要了解，例如 which+软件名 可以快速定位软件路径</p><p>4.mac在屏幕休眠状态下，默认不能下载。解决:设置-节能-磁盘别睡眠</p><p>5.如果出现权限被禁止，则在对应目录下，输入命令 sudo chmod -R 777 加上文件或者文件夹名即可</p><p>6.如有系统版本升级更新什么的，别升。</p><p>7.其实同价位的情况下，Mac是比不上Windows的</p><p>暂时就这么些了，后续再补充，也欢迎交流。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;用Mac已经好几个月了，之前想过整理出一篇博客，但是又觉得没什么必要。随后接连有几个朋友新入手了Mac，貌似即便是官方教学和其他博客来折腾，一方面是时间成本，另外一方面也是会有很多细节和技巧部分讲的不是太清楚，再就是和他们的交流中也的确会弥补自身的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>屏幕适配</title>
    <link href="https://igding.github.io/2018/07/05/%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D/"/>
    <id>https://igding.github.io/2018/07/05/屏幕适配/</id>
    <published>2018-07-05T07:42:42.000Z</published>
    <updated>2018-07-23T08:26:25.037Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>屏幕适配的文章已经有很多了，虽说有很多五花八门的适配方式。但是万变不离其宗，核心只有一个，就是算出dpi,再算出系数，再想办法以当前手机分辨率去乘以这个系数，无论是dimen，还是自定义布局获取子控件大小还是控制符sw</p></blockquote><p>本片主要以以下三点作为讲解</p><pre><code>A.基础部分和核心理念B.常用适配方式分析以及优缺点C.注意事项</code></pre><h2 id="A-基础部分和核心理念"><a href="#A-基础部分和核心理念" class="headerlink" title="A.基础部分和核心理念"></a>A.基础部分和核心理念</h2><h3 id="1-基础部分就略过了，整理出了一篇xmind-需要的朋友自行下载"><a href="#1-基础部分就略过了，整理出了一篇xmind-需要的朋友自行下载" class="headerlink" title="1. 基础部分就略过了，整理出了一篇xmind,需要的朋友自行下载"></a>1. 基础部分就略过了，整理出了一篇xmind,需要的朋友自行<a href="https://pan.baidu.com/s/1Thg27CNIIPKbYQ0Pnx7ieg" target="_blank" rel="noopener">下载</a></h3><p><img src="https://upload-images.jianshu.io/upload_images/3117705-bf8e498a7112c6b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="基础部分"></p><h3 id="2-核心"><a href="#2-核心" class="headerlink" title="2.核心"></a>2.核心</h3><p>px才是最小计算单位,也是最好的适配方式<br>Android自身有一套规则，160dpi为基准，1dp=1px或者1dip=1px</p><p>而其显示规则(原理)：假设机器的分辨率是1280*1080，尺寸为5，按照公式算出来的dpi为442，➗160得到的系数为2.75。如果在布局中写的100dp，那么在这台机器中显示的值为275px，而在每台手机的dpi不同，则显示的值则不同(具体按照公式计算即可)。同一个dp值，则可能会产生适配问题，我们设置dp时，dp只是兼容像素密度的单位，内部实际上还是转换成px来计算。</p><h2 id="B-常用适配方式分析以及优缺点"><a href="#B-常用适配方式分析以及优缺点" class="headerlink" title="B.常用适配方式分析以及优缺点"></a>B.常用适配方式分析以及优缺点</h2><h3 id="1-value"><a href="#1-value" class="headerlink" title="1.value"></a>1.value</h3><pre><code>优点：可以算出实际的px，最常用的就是洪阳的jar包原理：按照比例缩放，算出所有分辨率的px尺寸。缺点：1.太多xml文件，导致apk体积较大     2.px固定的太死了，不便于维护     3.如果有特例屏（如虚拟按键等），要单独计算出xml改良：用限定符sw,文件量可以缩小很多</code></pre><h3 id="2-限定符"><a href="#2-限定符" class="headerlink" title="2.限定符"></a>2.限定符</h3><h4 id="a-屏幕尺寸"><a href="#a-屏幕尺寸" class="headerlink" title="a.屏幕尺寸"></a>a.屏幕尺寸</h4><pre><code>small   小屏幕normal  基准屏幕large   大屏幕xlarge  超大屏幕</code></pre><h4 id="b-屏幕密度"><a href="#b-屏幕密度" class="headerlink" title="b.屏幕密度"></a>b.屏幕密度</h4><pre><code>ldpi    &lt;=120dpimdpi    &lt;= 160dpihdpi    &lt;= 240dpixhdpi   &lt;= 320dpixxhdpi  &lt;= 480dpixxhdpi  &lt;= 640dpi(只用来存放icon)nodpi   与屏幕密度无关的资源.系统不会针对屏幕密度对其中资源进行压缩或者拉伸tvdpi   介于mdpi与hdpi之间,特定针对213dpi,专门为电视准备的,手机应用开发不需要关心这个密度值.</code></pre><h4 id="c-屏幕方向"><a href="#c-屏幕方向" class="headerlink" title="c.屏幕方向"></a>c.屏幕方向</h4><pre><code>land    横向port    纵向</code></pre><h4 id="d-屏幕宽高比"><a href="#d-屏幕宽高比" class="headerlink" title="d.屏幕宽高比"></a>d.屏幕宽高比</h4><pre><code>long    比标准屏幕宽高比明显的高或者宽的这样屏幕notlong 和标准屏幕配置一样的屏幕宽高比</code></pre><h4 id="e-举例："><a href="#e-举例：" class="headerlink" title="e.举例："></a>e.举例：</h4><pre><code>平板适配(layout-swXXdp) small width，多套layout其中:layout-sw360dp即可适配大部分手机例如 1920*1080的手机，5-6寸算出dpi=500 系数500/160=3.125  对应分辨率的值为3.125 *360=11251125&gt;1080，目前针对手机，宽度很少有超过1080目前最大的手机屏幕分辨率2560 x 1440 5-6寸 dpi=587 系数3.6，值为1321，此时就要另算layout</code></pre><h3 id="3-自定义布局组件"><a href="#3-自定义布局组件" class="headerlink" title="3.自定义布局组件"></a>3.自定义布局组件</h3><pre><code>运行时换算，消耗性能      </code></pre><p><a href="">洪阳autolayout源码分析</a></p><h3 id="4-自带插件ScreenMatch"><a href="#4-自带插件ScreenMatch" class="headerlink" title="4.自带插件ScreenMatch"></a>4.自带插件ScreenMatch</h3><p><a href="https://blog.csdn.net/fesdgasdgasdg/article/details/78108169" target="_blank" rel="noopener">ScreenMatch参考链接</a></p><h3 id="5-百分比布局"><a href="#5-百分比布局" class="headerlink" title="5.百分比布局"></a>5.百分比布局</h3><pre><code>UI一般是给px,但是sketch里面是可以显示出百分比。具体使用自行查阅</code></pre><h2 id="C-注意事项"><a href="#C-注意事项" class="headerlink" title="C.注意事项"></a>C.注意事项</h2><ol><li>大型APP都会采用px来进行适配。因为px是最基本的单元。</li><li>dp不要去用</li><li>虚拟按键—–&gt;计算出虚拟按键的高度的分辨率，减去即可</li><li>推荐使用sw的方式进行适配</li><li>调试时，直接输入adb shell wm size 360dpx780dp，即可改成对应的屏幕分辨率，不需要开启多个模拟器来测<pre><code>adb shell wm size reset即可恢复</code></pre></li></ol><pre><code>刘海屏,全面屏，异形屏,凹形屏等-----&gt;参照对应厂商官方教学即可</code></pre><p><a href="https://devcenter-test.huawei.com/consumer/cn/devservice/doc/50114" target="_blank" rel="noopener">华为刘海屏</a><br><a href="https://open.oppomobile.com/service/message/detail?id=61876" target="_blank" rel="noopener">oppo凹形屏</a><br><a href="http://developer.huawei.com/consumer/cn/devservice/doc/50111" target="_blank" rel="noopener">全面屏</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;屏幕适配的文章已经有很多了，虽说有很多五花八门的适配方式。但是万变不离其宗，核心只有一个，就是算出dpi,再算出系数，再想办法以当前手机分辨率去乘以这个系数，无论是dimen，还是自定义布局获取子控件大小还是控制符sw&lt;/p&gt;
&lt;/blockquo
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>view测量布局绘制的源码分析</title>
    <link href="https://igding.github.io/2018/07/01/view%E6%B5%8B%E9%87%8F%E5%B8%83%E5%B1%80%E7%BB%98%E5%88%B6%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://igding.github.io/2018/07/01/view测量布局绘制的源码分析/</id>
    <published>2018-07-01T02:59:42.000Z</published>
    <updated>2018-07-01T15:01:14.217Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>view的绘制顺序是 measure layout draw。但是具体内部实现原理却不是很清楚，今天就对这整套流程来进行源码分析。</p></blockquote><h2 id="1-measure测量流程"><a href="#1-measure测量流程" class="headerlink" title="1.measure测量流程"></a>1.measure测量流程</h2><h3 id="a-起点ViewRootImpl中的performMeasure-方法"><a href="#a-起点ViewRootImpl中的performMeasure-方法" class="headerlink" title="a.起点ViewRootImpl中的performMeasure()方法"></a>a.起点ViewRootImpl中的performMeasure()方法</h3><pre><code>private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) {      mView.measure(childWidthMeasureSpec, childHeightMeasureSpec)}</code></pre><p>这两个参数，childWidthMeasureSpec和childHeightMeasureSpec<br>分别来源于</p><pre><code>int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);</code></pre><p>通过两个参数，得到根view的测量规格。</p><p>系统将View的LayoutParams根据父容器所施加的规则转换成对应的MeasureSpec(规格),然后在onMeasure中根据这个MeasureSpec来确定view的测量宽高。</p><p>我们通常在xml文件里面 会给布局添加宽高对应的模式，也就是match_parent和wrap_content再或者是自定义的大小,它的作用，告诉父容器，是要根据父容器来适配 还是要根据内容来适配。<br>先根据对应的模式，再加上对应的值 ，来确定最终的宽高。</p><p>总的来说就是：显示模式+实际值，来确定measure的值<br>高的显示模式 match_parent和值<br>宽的显示模式match_parent和值</p><p>我们再对这个传进来的参数进行分析<br>mWidth 在构造中就会赋值为 -1，之后具体的赋值暂时不管。<br>lp.width 这里的lp代表WindowManager.LayoutParams lp = mWindowAttributes;<br>资源文件，xml的信息，也就是Decorview中默认加载的那个xml</p><p>GetRootMeasureSpec()方法实现  规则产生对应的规格对象，onMeasure里面是根据measureSpec来确定高度的。</p><pre><code>private static int getRootMeasureSpec(int windowSize, int rootDimension) {  //      这里就是得到对应的规格  int measureSpec;  switch (rootDimension) {  case ViewGroup.LayoutParams.MATCH_PARENT:      // Window can&apos;t resize. Force root view to be windowSize.      measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);      break;  case ViewGroup.LayoutParams.WRAP_CONTENT:      // Window can resize. Set max size for root view.      measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);      break;  default:      // Window wants to be an exact size. Force root view to be that size.      measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);//主要需要分析的代码      break;  }  return measureSpec;}</code></pre><p>而这个MeasureSpec实际上是有三种规格</p><p><a href="http://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html" target="_blank" rel="noopener">源码反码补码</a></p><p><a href="">深入理解计算机系统</a></p><pre><code>public static class MeasureSpec {    private static final int MODE_SHIFT = 30;    private static final int MODE_MASK  = 0x3 &lt;&lt; MODE_SHIFT;    //int是4个字节，8个字符，十六进制就是32位。    //0x代表16进制，16进制的3 ,转换成10进制， 3*16的0次方，还是3。再转换成2进制    //3==&gt;0000 0000 0000 0000 0000 0000 0000 0000 00 11    //左移30， 变成   //110000 0000 0000 0000 0000 0000 0000 0000 00     最高位是符号位，代表是负数，同时，计算机存储的都是补码，所以需要取反，加1。得到原码。//110000 0000 0000 0000 0000 0000 0000 0000 00 补码//101111 1111 1111 1111 1111 1111 1111 1111 11 (取反，首位因为是负数，所以不取反，其他取反)//0 00000 0000 0000 0000 0000 0000 0000 0000  01(加1)//  1 01111 1111 1111 1111 1111 1111 1111 1111 11 //+ 0 00000 0000 0000 0000 0000 0000 0000 0000  01    //最终的值为 11 0000 0000 0000 0000 0000 0000 0000 0000  00//最高位是符号位，不参与计算，代表负数，也就是2的三十次方。就是-2的三十次方，得到-1073741824//这方面基础较差的朋友可以看下《深入理解计算机系统》//这样做的好处就是二进制计算速度快，而且一个值比两个值占的空间小。    public static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT;   //自己自定义，最终的值是0    public static final int EXACTLY     = 1 &lt;&lt; MODE_SHIFT;    //对应match_parent，最终值为2的30次方    public static final int AT_MOST     = 2 &lt;&lt; MODE_SHIFT;    //对应wrap_content，最终值为2的31次方(得到补码的值)}    //就是将大小和Spec进行打包。    //实际上这种计算规则就是 模式+具体数值--》规格      //数据格式32位,左两位代表模式，右30代表具体数值    public static int makeMeasureSpec(@IntRange(from = 0, to = (1 &lt;&lt; MeasureSpec.MODE_SHIFT) - 1) int size,                                      @MeasureSpecMode int mode) {        if (sUseBrokenMakeMeasureSpec) {            return size + mode;        } else {            return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);        }    }    //这里分别提供解包的mode和size功能    @MeasureSpecMode    public static int getMode(int measureSpec) {        //noinspection ResourceType        return (measureSpec &amp; MODE_MASK);    }    public static int getSize(int measureSpec) {        return (measureSpec &amp; ~MODE_MASK);    }</code></pre><p>得到根布局的规格，对应关系分别是<br>MeasureSpec.EXACTLY&lt;==&gt; match_parent<br>MeasureSpec.AT_MOST&lt;==&gt;wrap_content<br>MeasureSpec.UNSPECIFIED &lt;==&gt;常用于可滑动的view(如listview或者Recycleview等)</p><p>说白了也就是一种转换规则<br>要么跟父容器的大小 match-parent，<br>要么就是子控件的大小wrapContent，<br>要么就是自己自定义的大小。</p><p>同时这里需要理解，最初的xml的父容器如果是match_parent，它的parent实际上是DecorView默认加载进去的xml。</p><p>这个值会给到onMeasure，onMeasure是根据这个规格来确定view的宽高。<br>就是转换规则+具体大小，才是真实的宽高。</p><p>宽高得到交给performMeasure()方法，再会给到 mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);<br>从view.measure中会调用onMeasure()方法，内部setMeasureDimension(),该方法用于保存测量结果.这个只是给view来调用的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h3><p><code>最关键的其实是这个onMeasure()，我们所有的系统组件，无论是LinearLayout还是framelayout，都是重新的onMeasure这个方法而已。本质都是view，测量完之后，再onLayout进行摆放，最后再绘制而已，在onMeasure()中写一些业务代码。</code></p><h2 id="2-layout流程"><a href="#2-layout流程" class="headerlink" title="2.layout流程"></a>2.layout流程</h2><p>开始：performLayout(lp, mWidth, mHeight);//资源，宽，高</p><pre><code>   private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth,int desiredWindowHeight) {    final View host = mView;//这里的view实际上就是DecorView    if (host == null) {        return;    }   host.layout(0, 0, host.getMeasuredWidth(),        host.getMeasuredHeight());   }public void layout(int l, int t, int r, int b) {    if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) {       onMeasure(mOldWidthMeasureSpec,mOldHeightMeasureSpec);        //如果没有测量，就测量一遍        mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;    }    int oldL = mLeft;    int oldT = mTop;    int oldB = mBottom;    int oldR = mRight;    boolean changed = isLayoutModeOptical(mParent) ?            setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);    if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) {        onLayout(changed, l, t, r, b);//这里调用了onLayout    }</code></pre><p>而这个onLayout()方法的实现是个空的。</p><pre><code>protected void onLayout(boolean changed, int left, int top, int right,    int bottom) {   //提供给外部，加业务代码   }</code></pre><p>总结：<br><code>顶层的view调用layout，然后公开onLayout出去让别人重写，添加自身的业务，可以以FrameLayout的onLayout方法为例,内部自己去调用子View的layout方法，然后将子View点算完给他，让他自己去摆放所有的布局摆放，实际上就是每个view都有个layout去排版，排版会调用onLayout</code></p><p>流式布局来验证这些结论，但是这里只是一个demo，只是用于这些知识点，实际用于项目的 ，还需要另外进行计算。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>在7.0之后和7.0之前系统对于源码由一定程度的改变<br>7.0会导致onLayout可能会调用两次。</p><p>7.0的performTraversals() 内部有这样一行代码，会导致onMeasure()调用两次<br>            performDraw();<br>        } else {<br>            if (isViewVisible) {<br>                // Try again<br>                scheduleTraversals();//这里又会重新开始绘制流程(需要画一个流程图)<br>          }</p><p>ondraw内部又会调用  if (animating)<br>{<br>            mFullRedrawNeeded = true;<br>            scheduleTraversals();<br>        }</p><p>onMeasure,onMeasure,onLayout<br>onMeasure,onLayout，onMeasure,onLayout<br>onMeasure会调用两次。因为源码内部流程是重新走了一遍流程，具体是为什么 以及怎么写的，不太清楚。</p><h2 id="3-performDraw-流程-gt-drawSoftware-gt-draw-gt-ondraw"><a href="#3-performDraw-流程-gt-drawSoftware-gt-draw-gt-ondraw" class="headerlink" title="3.performDraw()流程==&gt;drawSoftware()==&gt;draw()==&gt;ondraw()"></a>3.performDraw()流程==&gt;drawSoftware()==&gt;draw()==&gt;ondraw()</h2><p>draw()方法中的</p><pre><code>private void draw(boolean fullRedrawNeeded) {    Surface surface = mSurface;//实际上就是一个画布    final Rect dirty = mDirty;//定一个矩阵，实际上就是在屏幕中去确认绘制范围。    //中间一大堆矩阵大小范围的源码略     if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) {                return;    }</code></pre><p>而drawSoftware中 则会调用mview.draw()。</p><pre><code>  private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff,        boolean scalingRequired, Rect dirty) {        final int left = dirty.left;        final int top = dirty.top;        final int right = dirty.right;        final int bottom = dirty.bottom;        final Canvas canvas;        canvas = mSurface.lockCanvas(dirty);//这里是调用底层C的代码，实际上的画布是Surface，而canvas实际上是类似于一个代理者，决定了图形的位置，形状等特性        mView.draw(canvas);        final Paint p = scrollabilityCache.paint;//paint决定了色彩和样式}</code></pre><p>mView.draw(canvas);才调用了ondraw</p><pre><code>public void draw(Canvas canvas) {/*     * Draw traversal performs several drawing steps which must be executed     * in the appropriate order:     *     *      1. Draw the background     *      2. If necessary, save the canvas&apos; layers to prepare for fading     *      3. Draw view&apos;s content     *      4. Draw children     *      5. If necessary, draw the fading edges and restore layers     *      6. Draw decorations (scrollbars for instance)     */                绘制的步骤：1.画background                          2.如果必要的话，保存canvas，用于渐变   (图形在绘制时，实际上是一层层叠加的，先保存当前层，第二次绘画，就重新在上面叠加一层，  涉及到这样的步骤。所以我们在定位，如果定在某一层，则会把下面的层级给覆盖掉)                          3.画view的内容                          4.画子view                          5.如果必要，绘制渐变恢复                          6.绘制装饰(例如滚动条)   // skip step 2 &amp; 5 if possible (common case)   // Step 3, draw the content    if (!dirtyOpaque) onDraw(canvas);    // Step 4, draw the children        dispatchDraw(canvas);    //Step 5        drawAutofilledHighlight(canvas);        // Overlay is part of the content and draws beneath Foreground        if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) {            mOverlay.getOverlayView().dispatchDraw(canvas);        }        // Step 6, draw decorations (foreground, scrollbars)        onDrawForeground(canvas);        // Step 7, draw the default focus highlight        drawDefaultFocusHighlight(canvas);        if (debugDraw()) {            debugDrawFocus(canvas);        }        // we&apos;re done...        return;    }</code></pre><h3 id="step1：drawBackground（）源码分析："><a href="#step1：drawBackground（）源码分析：" class="headerlink" title="step1：drawBackground（）源码分析："></a>step1：drawBackground（）源码分析：</h3><pre><code>private void drawBackground(Canvas canvas) {    final Drawable background = mBackground;    if (background == null) {        return;    }    setBackgroundBounds();//设置背景边框    final int scrollX = mScrollX;    final int scrollY = mScrollY;    if ((scrollX | scrollY) == 0) {        background.draw(canvas);//为原点就开始绘制    } else {        canvas.translate(scrollX, scrollY);//不是原点就回到原点进行绘制        background.draw(canvas);        canvas.translate(-scrollX, -scrollY);    }}</code></pre><h3 id="step3：-onDraw-源码分析："><a href="#step3：-onDraw-源码分析：" class="headerlink" title="step3： onDraw() 源码分析："></a>step3： onDraw() 源码分析：</h3><pre><code>   /** * Implement this to do your drawing. * * @param canvas the canvas on which the background will be drawn */protected void onDraw(Canvas canvas) {      //实际上就是对外提供方法}</code></pre><h3 id="step4：dispatchDraw-源码分析，绘画子view"><a href="#step4：dispatchDraw-源码分析，绘画子view" class="headerlink" title="step4：dispatchDraw()源码分析，绘画子view"></a>step4：dispatchDraw()源码分析，绘画子view</h3><pre><code> /** * Called by draw to draw the child views. This may be overridden * by derived classes to gain control just before its children are drawn * (but after its own view has been drawn). * * @param canvas the canvas on which to draw the view */protected void dispatchDraw(Canvas canvas) {  //提供给子view的，最典型的就是ViewGroup的体系，如listview}</code></pre><h3 id="step5-drawAutofilledHighlight（）"><a href="#step5-drawAutofilledHighlight（）" class="headerlink" title="step5: drawAutofilledHighlight（）"></a>step5: drawAutofilledHighlight（）</h3><pre><code>//恢复图层，理解成save和restore就好了。。实际上是涉及到底层的OpenGL以及优化层面的东西，图形的绘制都是GPU来处理的private void drawAutofilledHighlight(@NonNull Canvas canvas) {    if (isAutofilled()) {        Drawable autofilledHighlight = getAutofilledDrawable();        if (autofilledHighlight != null) {            autofilledHighlight.setBounds(0, 0, getWidth(), getHeight());            autofilledHighlight.draw(canvas);        }    }}</code></pre><h3 id="step-6和7就是-绘制view的装饰"><a href="#step-6和7就是-绘制view的装饰" class="headerlink" title="step 6和7就是 绘制view的装饰"></a>step 6和7就是 绘制view的装饰</h3><p><a href="https://github.com/hongyangAndroid/FlowLayout/blob/master/flowlayout-lib/src/main/java/com/zhy/view/flowlayout/FlowLayout.java" target="_blank" rel="noopener">FlowLayout源码分析</a>帮助理解measureSpec</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;view的绘制顺序是 measure layout draw。但是具体内部实现原理却不是很清楚，今天就对这整套流程来进行源码分析。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-measure测量流程&quot;&gt;&lt;a href=&quot;#1-measu
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Handler源码分析</title>
    <link href="https://igding.github.io/2018/06/12/Handler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://igding.github.io/2018/06/12/Handler源码分析/</id>
    <published>2018-06-12T07:42:42.000Z</published>
    <updated>2018-06-19T06:13:13.168Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>不太喜欢长篇大论和裹脚布般的源码分析，经常看到很多博主冷不丁的就冒出来几个新词汇，然后一股脑就钻到代码细节上，搞的人很懵逼，习惯性的吐槽和无可奈何的强迫式专研，终才搞懂。但是即便懂了，再回头看原先的部分文章，还是忍不住吐槽。直到某一天，鸡排大佬的一句:”你行你上” 点醒了我，于是乎，就开始自己来折腾。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不仅仅只做源码分析和流程总结，最好是把核心流程动手敲一遍，结合设计模式思考这样设计的优缺点</span><br></pre></td></tr></table></figure><p>首先，假装我们什么都不懂。。</p><p>准备工作：</p><blockquote><p>1.Handler：线程之间的交互<br>2.Message ：消息<br>3.MessagePool：缓存消息和回收<br>4.Looper： 为线程提供驱动，从MessageQueue中提取消息<br>5.MessageQueue ：消息存储单元，名为队列，实则单链表<br>6.ThreadLocal:以当前线程作为key，looper作为value存储,可以理解成是Map，但是内部实现是table数组<br>6.消费者生产者模式<br>7.多线程常识<br>8.队列，链表<br>9.基本常识<br>a.UI线程就是主线程<br>b.主线程默认可以使用handler是因为ActivityThread的main方法中就为主线程提供了looper。</p></blockquote><p>我们以 “问题&lt;==&gt;Demo”的形式作为切入点，来进行源码分析：</p><h2 id="问题1：主线程和子线程为毛要进行交互呢，交互场景是什么呢？？"><a href="#问题1：主线程和子线程为毛要进行交互呢，交互场景是什么呢？？" class="headerlink" title="问题1：主线程和子线程为毛要进行交互呢，交互场景是什么呢？？"></a><a href="https://igding.github.io/2018/06/12/Handler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#%E9%97%AE%E9%A2%981%EF%BC%9A%E4%B8%BB%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%AD%90%E7%BA%BF%E7%A8%8B%E4%B8%BA%E6%AF%9B%E8%A6%81%E8%BF%9B%E8%A1%8C%E4%BA%A4%E4%BA%92%E5%91%A2%EF%BC%8C%E4%BA%A4%E4%BA%92%E5%9C%BA%E6%99%AF%E6%98%AF%E4%BB%80%E4%B9%88%E5%91%A2%EF%BC%9F%EF%BC%9F" title="问题1：主线程和子线程为毛要进行交互呢，交互场景是什么呢？？"></a>问题1：主线程和子线程为毛要进行交互呢，交互场景是什么呢？？</h2><h3 id="常识1："><a href="#常识1：" class="headerlink" title="常识1："></a><a href="https://igding.github.io/2018/06/12/Handler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#%E5%B8%B8%E8%AF%861%EF%BC%9A" title="常识1："></a>常识1：</h3><blockquote><p>Android内，你能写的绝大多数的代码(除了开线程或者用到三方库内部开了线程外)都是在主线程内，但是主线程不能做过多的耗时操作，不然轻则卡顿(The application may be doing too much work on its main thread)，重则产生ANR<br><a href="https://upload-images.jianshu.io/upload_images/3117705-973b6a0f27fa5c43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/3117705-89946b144473463b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></a></p></blockquote><p>理论上Activity是5秒，广播则十秒，但是实际经测试发现，具体时间是跟系统版本和手机有关，另外实测5.0以上的模拟器貌似出现不了这种弹窗。不知道为毛。<br><a href="https://upload-images.jianshu.io/upload_images/3117705-a745d2b8ed5be08f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/3117705-29364be522245f92?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></a> </p><p>小插曲：记得有次面试，面试官问我，主线程能否做耗时操作，答之不能，那货强行说可以，耗时是抽象词汇，5秒也算耗时。无语~</p><p>不过其实这里也可以扩展到内存优化的知识点，暂时就不跑偏了。继续刚才的问题，交互场景</p><p>既然主线程不能做耗时操作，要分流一部分工作交给子线程，例如联网请求，子线程得到值，赋值给控件时，就会产生下列问题：</p><h2 id="Demo2"><a href="#Demo2" class="headerlink" title="Demo2"></a><a href="https://igding.github.io/2018/06/12/Handler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#Demo2" title="Demo2"></a>Demo2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line">       @Override</span><br><span class="line">       public void run() &#123;</span><br><span class="line">           button.setText(&quot;button&quot;);</span><br><span class="line">           Toast.makeText(MainActivity.this, &quot;已点击&quot;, Toast.LENGTH_LONG).show();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;).start();</span><br></pre></td></tr></table></figure><blockquote><p>报错信息：android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.</p></blockquote><p>这段报错检验，实际上来自于ViewRootImpl的checkThread()方法。这里暂时不做扩展</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> void checkThread() &#123;</span><br><span class="line">    if (mThread != Thread.currentThread()) &#123;</span><br><span class="line">        throw new CalledFromWrongThreadException(</span><br><span class="line">                &quot;Only the original thread that created a view hierarchy     can touch its views.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">报错信息说明，只能在主线程做UI更新操作</span><br></pre></td></tr></table></figure><blockquote><p>这里就产生了几个问题<br>1.为什么不能在子线程做UI更新操作？<br>2.就想在子线程创建handler，做ui更新操作不行吗？</p></blockquote><p>1.UI线程是单线程模型，多线程并发访问UI，会导致UI不可预期，如果加锁机制，一方面逻辑很复杂，另外一方面降低UI效率，同时锁机制可能会造成线程阻塞</p><p>2.不能在其他线程创建handler，没有调用Looper.prepare()方法</p><p>Can’t create handler inside thread that has not calle Looper.prepare()</p><h2 id="Demo3"><a href="#Demo3" class="headerlink" title="Demo3"></a><a href="https://igding.github.io/2018/06/12/Handler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#Demo3" title="Demo3"></a>Demo3</h2><p>随手Google一番，查阅到几个更新UI的方法<br>1.runOnUiThread()<br>2.View.post(Runnable r)<br>3.handler</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">//方法一：   </span><br><span class="line"> @Override</span><br><span class="line">public final void runOnUiThread(Runnable action) &#123;</span><br><span class="line">    if (Thread.currentThread() != mUiThread) &#123;</span><br><span class="line">    //mUiThread的赋值是Activity在attach()时获取当前线程，那肯定就是主线程(UI线程)。</span><br><span class="line">        mHandler.post(action);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        action.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//方法二:</span><br><span class="line"> public boolean post(Runnable action) &#123;</span><br><span class="line">    final AttachInfo attachInfo = mAttachInfo;</span><br><span class="line">//mAttachInfo在View的dispatchAttachedToWindow()中赋值</span><br><span class="line">//在dispatchDetachedFromWindow()中置空</span><br><span class="line">//所以肯定不为null,会走if内部的方法，实际上还是handler.post()</span><br><span class="line">    if (attachInfo != null) &#123;</span><br><span class="line">        return attachInfo.mHandler.post(action);</span><br><span class="line">    &#125;</span><br><span class="line">    getRunQueue().post(action);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//方法三</span><br><span class="line"> Handler handler = new Handler() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handleMessage(Message msg) &#123;//结束</span><br><span class="line">        switch (msg.what) &#123;</span><br><span class="line">            case 1:</span><br><span class="line">                button.setText(String.valueOf(msg.obj));</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">        &#125;</span><br><span class="line">        super.handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onClick(View v) &#123;</span><br><span class="line">    new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            Message message = Message.obtain();//切入点2</span><br><span class="line">            message.what = 1;</span><br><span class="line">            message.obj = &quot;button&quot;;</span><br><span class="line">            handler.sendMessage(message);//切入点1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();//start()才是开启线程，run()只是一个普通的方法，run执行完才代表结束。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法一和方法二内部是在调用mHandler.post()。而三者内部实际上都是在调用sendMessageAtTime()，也就是说这三种实际上都是同一种。都是采用的handler机制。为了让主线程和子线程进行通信</p><blockquote><p>这里又会引发出几个问题<br>1.Java的多线程通信是怎么做的？<br>2.Android为何不沿用Java的多线程通信方式,而偏偏要用handler处理？<br>3.具体的交互流程是什么？这样设计有什么好处？</p></blockquote><p>结合入口的sendMessage()和出口的handleMessage()就可以推导出整个handler内部的流程</p><p>逆推法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public boolean sendMessageAtTime(Message msg, long     uptimeMillis) &#123;</span><br><span class="line">    MessageQueue queue = mQueue;//来自于构造方法Looper.myLooper()</span><br><span class="line">    if (queue == null) &#123;</span><br><span class="line">        RuntimeException e = new RuntimeException(</span><br><span class="line">                this + &quot; sendMessageAtTime() called with no mQueue&quot;);</span><br><span class="line">        Log.w(&quot;Looper&quot;, e.getMessage(), e);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> public Handler(Callback callback, boolean async) &#123;//Handler的空参构造是有调用这里的</span><br><span class="line">    if (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">        final Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class="line">        if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123;</span><br><span class="line">            Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +</span><br><span class="line">                klass.getCanonicalName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    if (mLooper == null) &#123;</span><br><span class="line">        throw new RuntimeException(</span><br><span class="line">            &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> public Handler() &#123;</span><br><span class="line">    this(null, false);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</span><br><span class="line">    msg.target = this;//message存到MessageQueue时 会做一个标记</span><br><span class="line">    return queue.enqueueMessage(msg, uptimeMillis);//这里的方法就是在对Message进行排队</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">           for (; ; ) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                if (p == null || when &lt; p.when) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; // invariant: p == prev.next</span><br><span class="line">            prev.next = msg;</span><br></pre></td></tr></table></figure><p>从这里可以看出几点</p><p>1.Message会做个标记target,然后存入到MessageQueue中。<br>2.一个MessageQueue对应一个looper()。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  public static @Nullable Looper myLooper() &#123;</span><br><span class="line">    return sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.Looper是从sThreadLocal中得到的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> private static void prepare(boolean quitAllowed) &#123;</span><br><span class="line">    if (sThreadLocal.get() != null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(new Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里就有一个疑问，为什么要有ThreadLocal这个类？<br>  因为ThreadLocal不仅仅用于looper机制，而且还有activityThread，以及AMS等。如果不用ThreadLocal的话，就需要用一个全局的哈希表，而且还要对应的manager类来进行管理，就比较麻烦。<br>另外一方面，可以从设计者的角度来考虑，有一大好处<br>处理存取工作，抽取到专门的类中处理，无论是解耦还是复用性。</p></blockquote><p>4.在looper的prepare()方法中，set了一个looper.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> public void set(T value) &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.ThreadLocal的set方法，实际上就是得到一个ThreadLocalMap,以当前线程作为key，值作为value，进行存储。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> public T get() &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(this);</span><br><span class="line">        if (e != null) &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> private Looper(boolean quitAllowed) &#123;</span><br><span class="line">    mQueue = new MessageQueue(quitAllowed);</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切入点2：Message.obtain();消息是如何产生的？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> public static Message obtain() &#123;</span><br><span class="line">    synchronized (sPoolSync) &#123;</span><br><span class="line">        if (sPool != null) &#123;</span><br><span class="line">            Message m = sPool;</span><br><span class="line">            sPool = m.next;</span><br><span class="line">            m.next = null;</span><br><span class="line">            m.flags = 0; // clear in-use flag</span><br><span class="line">            sPoolSize--;</span><br><span class="line">            return m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return new Message();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void recycleUnchecked() &#123;</span><br><span class="line">    flags = FLAG_IN_USE;</span><br><span class="line">    what = 0;</span><br><span class="line">    arg1 = 0;</span><br><span class="line">    arg2 = 0;</span><br><span class="line">    obj = null;</span><br><span class="line">    replyTo = null;</span><br><span class="line">    sendingUid = -1;</span><br><span class="line">    when = 0;</span><br><span class="line">    target = null;</span><br><span class="line">    callback = null;</span><br><span class="line">    data = null;</span><br><span class="line"></span><br><span class="line">    synchronized (sPoolSync) &#123;</span><br><span class="line">        if (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">            next = sPool;</span><br><span class="line">            sPool = this;</span><br><span class="line">            sPoolSize++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里就可以分析出整个流程了</p><blockquote><p>1.我们都知道程序的入口是ActivityThread的main()方法，其中调用了loop.prepareMainLooper(),为主线程提供一个looper,并且把looper和当前线程Thread存放到ThreadLocal中<br>2.从handler的构造中拿到Looper，而这个looper是从ThreadLocal.get获取到的<br>3.message.target实际上就是把message和handler相绑定，一起存入到MessageQueue中，一个Looper对应一个MessageQueue。<br>4.在MessageQueue中进行排列</p></blockquote><p>入口方向就可以分析到这里</p><p>那么出口handleMessage又是如何得到的Message的？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void handleMessage(Message msg) &#123;//是由dispatchMessage()在调用</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Handle system messages here.</span><br><span class="line"> */</span><br><span class="line">public void dispatchMessage(Message msg) &#123;</span><br><span class="line">    if (msg.callback != null) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (mCallback != null) &#123;</span><br><span class="line">            if (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而dispatchMessage()则是在Looper的loop()方法中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">final MessageQueue queue = me.mQueue;</span><br><span class="line"> for (;;) &#123;//死循环获取数据</span><br><span class="line">     Message msg = queue.next(); </span><br><span class="line">     if (msg == null) &#123;//如果消息没有了，就return出这个死循环</span><br><span class="line">         return;</span><br><span class="line">     &#125;</span><br><span class="line">     msg.recycleUnchecked();//消息被回收</span><br></pre></td></tr></table></figure><p>Looper的loop()又是在ActivityThread中被调用，从而完成了整个流程</p><p>这就是handler的一个流程分析。</p><p><a href="https://upload-images.jianshu.io/upload_images/3117705-ddb7f19c46db967d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/3117705-5e4071d3a2fc5b2f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></a> </p><p>当然也涉及到非常多细节部分<br>1、ThreadLocal是如何保证当前线程就是<br>2、MessagePool是如何操作Message的<br>3、MessageQueue是如何存放Message的<br>4、looper又是如何取Message的<br>5、即便是整个流程知道了，那对我们开发又有什么好处？</p><h2 id="Demo6"><a href="#Demo6" class="headerlink" title="Demo6"></a><a href="https://igding.github.io/2018/06/12/Handler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#Demo6" title="Demo6"></a>Demo6</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"> @Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    button = findViewById(R.id.button);</span><br><span class="line">    new Thread() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            button.setText(&quot;111&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    button = findViewById(R.id.button);</span><br><span class="line">    new Thread() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            button.setText(&quot;111&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    button = findViewById(R.id.button);</span><br><span class="line">    button.setOnClickListener(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onClick(View v) &#123;</span><br><span class="line">    new Thread() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            button.setText(&quot;111&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个demo没有报错，第二个和第三个demo报错了</p><p>MessageQueue用到了生产者和消费者的设计模式。因为N多子线程 各自自带的消息数量都不一样</p><p><a href="https://github.com/igding/handler" target="_blank" rel="noopener">仿写handler源码</a></p><p>这里只是初步仿写，完成一个主架构<br>核心在于两点<br>1：Message利用handler发送消息<br>2：MessageQueue的生产者消费者模式<br>后续会逐步完善<br>还需要对多线程，数据结构以及设计模式再熟悉一下，然后重新回顾一下handler</p><p>完全理解handler，除了一些基本流程之外，还需要知道<br>关于无限循环的阻塞问题。<br>Messagequeue中的for循环问题<br>单链表和队列问题<br>handler引起的内存泄漏以及解决办法<br>非静态内部类隐士持有外部类引用。<br>弱引用即可==》还涉及到四大引用==》配合线程和线程池以及各大三方库<br>另外补充一些关于handler的面试题</p><p>未完待续。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;不太喜欢长篇大论和裹脚布般的源码分析，经常看到很多博主冷不丁的就冒出来几个新词汇，然后一股脑就钻到代码细节上，搞的人很懵逼，习惯性的吐槽和无可奈何的强迫式专研，终才搞懂。但是即便懂了，再回头看原先的部分文章，还是忍不住吐槽。直到某一天，鸡排大佬的一
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>View的工作原理</title>
    <link href="https://igding.github.io/2018/06/12/View%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>https://igding.github.io/2018/06/12/View的工作原理/</id>
    <published>2018-06-12T07:42:42.000Z</published>
    <updated>2018-07-01T15:11:21.675Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qian520ao/article/details/78657084" target="_blank" rel="noopener">参考链接</a></p><p>ViewRootImpl：负责view的布局 测量 绘制</p><p>DecorView:<br>因为oncreate走完，仅仅只是资源的准备工作，实际view的绘制工作是在onresume()中进行的，同时，这里要看ActivityThread的handlerMessage()方法中的RESUME_ACTIVITY，会走handleResumeActivity()方法中，performResumeActivity()方法得到一个ActivityRecord</p><pre><code>  ViewManager wm = a.getWindowManager();  WindowManager.LayoutParams l = r.window.getAttributes();  a.mDecor = decor;  l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;  l.softInputMode |= forwardBit; if (r.mPreserveWindow) {     a.mWindowAdded = true;     r.mPreserveWindow = false;     ViewRootImpl impl = decor.getViewRootImpl();       if (impl != null) {          impl.notifyChildRebuilt();        }     }if (a.mVisibleFromClient) {    if (!a.mWindowAdded) {       a.mWindowAdded = true;       wm.addView(decor, l);//核心代码，l代表的是所有的资源和decorView添加到ViewManager </code></pre><p>wm是一个接口，接口addView,实际就要找到它的一个实现类，也就是WindowManagerGlobal中的addView()，只是这里运用到了一个设计模式，直接分析WindowManagerGlobal的addView即可</p><p>核心代码</p><pre><code>       //前面一堆系统调用和资源配置就忽略掉了，主要是以下代码       root = new ViewRootImpl(view.getContext(), display);       view.setLayoutParams(wparams);       mViews.add(view);//这三个add实际上是三个list       mRoots.add(root);       mParams.add(wparams);       root.setView(view, wparams, panelParentView);//核心代码ArrayList&lt;View&gt; mViews = new ArrayList&lt;View&gt;();ArrayList&lt;ViewRootImpl&gt; mRoots = new ArrayList&lt;ViewRootImpl&gt;();ArrayList&lt;WindowManager.LayoutParams&gt; mParams =new ArrayList&lt;WindowManager.LayoutParams&gt;();</code></pre><p>ViewRoot的setView()源码分析<br>内部主要有一个requestLayout() ==&gt; scheduleTraversals()==&gt; mChoreographer.postCallback(Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);==&gt;实际上是调用了这个runable，而这个runable内部实际上是调用了doTraversal()方法</p><pre><code>final class TraversalRunnable implements Runnable {    @Override    public void run() {        doTraversal();    }}</code></pre><p>doTraversal中的核心方法是performTraversals();这里才正式开启了UI的绘制流程</p><p>WindowManage.LayoutParams，所有的资源都在这里<br>Rect frame 绘制了一个矩形。这个矩形并不是画布，而是意思大概就是，先确定他的整体位置</p><p>中间是一大堆比较恶心的计算。</p><p>下面，有一个测量方法performMeasure()，调用view的measure,再调用自身的onMeasure()方法<br>performLayout()布局==&gt;view的layout(),再调用自身的onLayout()；<br>performDraw()绘制==&gt;view的draw(),再调用自身的onDraw()；<br>draw中才会有surface画布，这个时候view才会显示出来</p><p>setContentView只是资源的准备<br>onresume才是真正的布局测量绘制</p><p>下一篇，对测量 布局 绘制流程的详细分析。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qian520ao/article/details/78657084&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ViewRootImpl：负责view的布局 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>setContentView源码分析</title>
    <link href="https://igding.github.io/2018/06/12/setContentView%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://igding.github.io/2018/06/12/setContentView源码分析/</id>
    <published>2018-06-12T07:42:42.000Z</published>
    <updated>2018-06-15T09:56:44.947Z</updated>
    
    <content type="html"><![CDATA[<p>ViewRoot 继承自framelayout, 根布局<br>Window<br>DecorView</p><pre><code> public void setContentView(@LayoutRes int layoutResID) {    getWindow().setContentView(layoutResID);//实际上是getWindow()在调用，    initWindowDecorActionBar();//设置ActionBar(不包含状态栏)} public Window getWindow() {    return mWindow;}// Window类的注释代码only existing implementation is PhoneWindow public abstract class Window {//唯一的实现类是PhoneWindow}</code></pre><p>PhoneWindow的setContentView核心源码</p><pre><code>  if (mContentParent == null) {//mContentParent是viewgroup      installDecor();//初始化Decor  } //设置我们的布局填充到mContentParentmLayoutInflater.inflate(layoutResID, mContentParent);</code></pre><p>这段代码说明了，实际上我们的布局文件之上，还有一个父容器viewgroup</p><pre><code>private void installDecor() {   if (mDecor == null) {       mDecor = generateDecor(-1);//创建一个DecorView       //设置的属性和动画效果直接忽略   else {       mDecor.setWindow(this);//DecorView设置一个window   }   if (mContentParent == null) {       mContentParent = generateLayout(mDecor);     //如果viewgroup为空，则生成一个layout</code></pre><p> generateDecor源码分析</p><pre><code>protected DecorView generateDecor(int featureId) {    //内部就是new了一个DecorView。    return new DecorView(context, featureId, this, getAttributes());}</code></pre><p>generateLayout()源码分析</p><blockquote><p>generateLayout内部实际上就是在setFlags和setLayout和style和requestFeature()和动画一系列的操作最终就是在创建一个DecorView。同时，也印证了，在设置getWindow.requestFeature时，为什么要设置在setContentView()之前，因为这些在之前就已经设置了。最后是会根据不同的状态去加载不同的布局</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/3117705-a444441d4d1a35b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><pre><code>//最后会加载layoutResourcemDecor.onResourcesLoaded(mLayoutInflater, layoutResource);</code></pre><p>onResourcesLoaded内部实际上就是把layoutResource填充进来</p><pre><code>void onResourcesLoaded(LayoutInflater inflater, int layoutResource) {      final View root = inflater.inflate(layoutResource, null);}</code></pre><p>创建完父容器之后，再去填充我们自己的布局，底层是用的xml解析，解析过程(略)。</p><p>也就是说，setContentView()实际上就是两步<br>1.加载父容器(包括各种style和各类资源等)，<br>2.加载自身布局</p><p>但是这里仅仅只是加载，正如我们最初在学activity生命周期时，很明确的说明，oncreate()只是在准备阶段，加载资源文件，也就是说，没有将view添加到window。因为oncrete中setContentView()仅仅只是资源准备阶段，只有当ActivityThread执行onReLauchActivity时，也就是onResume()方法时，才会将view添加到window中</p><p><img src="https://upload-images.jianshu.io/upload_images/3117705-d5345a767c2b0d0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>下一篇，将会讲解，DecorView是如何添加到窗口window的源码分析</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ViewRoot 继承自framelayout, 根布局&lt;br&gt;Window&lt;br&gt;DecorView&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; public void setContentView(@LayoutRes int layoutResID) {
    getWindo
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>源码分析的方法</title>
    <link href="https://igding.github.io/2018/06/12/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://igding.github.io/2018/06/12/源码分析的方法/</id>
    <published>2018-06-12T07:42:42.000Z</published>
    <updated>2018-09-03T09:27:07.058Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本人水平有限，以下内容只能作为探讨和交流，如果有错误或者不足的地方，还请指正，相互学习。</p></blockquote><h2 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h2><h3 id="SDK版本Android-27"><a href="#SDK版本Android-27" class="headerlink" title="SDK版本Android-27"></a>SDK版本Android-27</h3><p><img src="https://upload-images.jianshu.io/upload_images/3117705-9747fe3d3945b59a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>    还需要修改导入的包  implementation ‘com.android.support:appcompat-v7:27.1.0’<br>    也可以<a href="http://androidxref.com" target="_blank" rel="noopener">在线源码查看</a></p><h3 id="修改sdk的jar包"><a href="#修改sdk的jar包" class="headerlink" title="修改sdk的jar包"></a><a href="https://pan.baidu.com/s/1f9xxwmJR28_QfwA89AZSRg" target="_blank" rel="noopener">修改sdk的jar包</a></h3><p>Android Studio中双击shift，输入sdkManager,找到sdk路径<br><img src="https://upload-images.jianshu.io/upload_images/3117705-4abe58be869fee78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>copy路径，放入对应sdk下 覆盖jar包即可</p><p><img src="https://upload-images.jianshu.io/upload_images/3117705-124df15d4a35267e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p>注意事项：<br>1.最好只操作27版本的，其他版本暂时不清楚会不会出问题<br>2.不会影响公司项目，这只是工具层的东西，不是编译层<br>3.当然你也可以用<a href="https://www.jianshu.com/p/c82817feba38" target="_blank" rel="noopener">Source Insight或者在线阅读源码</a>，我暂时不太习惯</p></blockquote><h2 id="心德"><a href="#心德" class="headerlink" title="心德"></a>心德</h2><h3 id="1-借助博客，多看几篇，了解初步原理和大概的用处"><a href="#1-借助博客，多看几篇，了解初步原理和大概的用处" class="headerlink" title="1.借助博客，多看几篇，了解初步原理和大概的用处"></a>1.借助博客，多看几篇，了解初步原理和大概的用处</h3><h3 id="2-xmind和uml帮助理解，掌握全局性的流程"><a href="#2-xmind和uml帮助理解，掌握全局性的流程" class="headerlink" title="2.xmind和uml帮助理解，掌握全局性的流程"></a>2.xmind和uml帮助理解，掌握全局性的流程</h3><h3 id="3-以基础api或者面试题作为切入点，带着问题看"><a href="#3-以基础api或者面试题作为切入点，带着问题看" class="headerlink" title="3.以基础api或者面试题作为切入点，带着问题看"></a>3.以基础api或者面试题作为切入点，带着问题看</h3><h3 id="4-只看关键代码和注释，分析对象之间的关系"><a href="#4-只看关键代码和注释，分析对象之间的关系" class="headerlink" title="4.只看关键代码和注释，分析对象之间的关系"></a>4.只看关键代码和注释，分析对象之间的关系</h3><h3 id="5-结合设计模式思考为什么这样设计，解决了什么问题"><a href="#5-结合设计模式思考为什么这样设计，解决了什么问题" class="headerlink" title="5.结合设计模式思考为什么这样设计，解决了什么问题"></a>5.结合设计模式思考为什么这样设计，解决了什么问题</h3><h3 id="6-书籍-艺术探索，进阶之光，源码解析与实战"><a href="#6-书籍-艺术探索，进阶之光，源码解析与实战" class="headerlink" title="6.书籍 艺术探索，进阶之光，源码解析与实战"></a>6.书籍 艺术探索，进阶之光，源码解析与实战</h3><h3 id="7-在此应用场景下，优缺点是什么，最好是自己来手写一遍-只用写主要的功能，去除细枝末节"><a href="#7-在此应用场景下，优缺点是什么，最好是自己来手写一遍-只用写主要的功能，去除细枝末节" class="headerlink" title="7.在此应用场景下，优缺点是什么，最好是自己来手写一遍(只用写主要的功能，去除细枝末节)"></a>7.在此应用场景下，优缺点是什么，最好是自己来手写一遍(只用写主要的功能，去除细枝末节)</h3><h3 id="8-忘了也不要紧，写博客详细记录自己的分析过程，到时候回顾起来很方便"><a href="#8-忘了也不要紧，写博客详细记录自己的分析过程，到时候回顾起来很方便" class="headerlink" title="8.忘了也不要紧，写博客详细记录自己的分析过程，到时候回顾起来很方便"></a>8.忘了也不要紧，写博客详细记录自己的分析过程，到时候回顾起来很方便</h3><pre><code>本人方面，也只是在实践的过程当中。有待提高</code></pre><p>光说不练假把式，接下来我会以新手的身份，重新学习Android，并整理出自己的知识体系。</p><p>下一篇 Activity启动流程</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本人水平有限，以下内容只能作为探讨和交流，如果有错误或者不足的地方，还请指正，相互学习。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;准备工作：&quot;&gt;&lt;a href=&quot;#准备工作：&quot; class=&quot;headerlink&quot; title=&quot;准备工
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>win7升级win10(简单高效无脑)</title>
    <link href="https://igding.github.io/2018/03/23/win7%E5%8D%87%E7%BA%A7win10(%E7%AE%80%E5%8D%95%E9%AB%98%E6%95%88%E6%97%A0%E8%84%91)/"/>
    <id>https://igding.github.io/2018/03/23/win7升级win10(简单高效无脑)/</id>
    <published>2018-03-23T13:03:53.578Z</published>
    <updated>2018-03-25T14:32:03.881Z</updated>
    
    <content type="html"><![CDATA[<pre><code>老王: win10现在还免费吗?  我: 免费的，免费的老王: 升了到底有啥好处呢？  我: 效率逼格就不说了，主要是默认保留原有文件和自带恢复出厂设置，以后就不需要为系统的事操心了。老王: 真能保存之前文件吗？不影响吗？  我: 是真的，是真的。不影响，不影响。众人: 我没有u盘，我怕装了出问题，就这样吧。太麻烦了，不想搞 我: 去去去，你们怕是个假程序猿。都说了是简单无脑高效。</code></pre><p>直接进入正题吧。</p><p>###提前准备工作：</p><p>1.<a href="https://download.microsoft.com/download/0/1/6/01677C03-1D89-49FD-B49B-87B0F36B00D1/Windows10Upgrade24074.exe" target="_blank" rel="noopener">微软官方的工具</a></p><pre><code>该链接目前没有公开，下载后无脑安装即可，记得电脑必须充电且联网，win10自动安装驱动。</code></pre><p>2.<a href="http://www.drvceo.com/" target="_blank" rel="noopener">微软官方的工具</a></p><pre><code>安装完系统之后，再来一发这个</code></pre><p>3.<a href="http://tieba.baidu.com/f?kw=windows10&amp;ie=utf-8&amp;tab=good" target="_blank" rel="noopener">参考链接  Windows10吧</a></p><p>4.U盘或者移动硬盘</p><pre><code>可有可无，以防万一</code></pre><blockquote><p>老王：可我习惯用老毛桃和大白菜。<br>我：请自行百度”老毛桃U盘制作后门”,“大白菜Ghost病毒”</p></blockquote><p>###具体操作流程</p><pre><code>无脑下一步,大概耗时1h</code></pre><h3 id="可能出现的问题："><a href="#可能出现的问题：" class="headerlink" title="可能出现的问题："></a>可能出现的问题：</h3><p>1.运行升级软件时，无法启动程序，计算机丢失api-ms-win-core-libraryloader-l1-1-1.dll</p><pre><code>将Windows10Upgrade的wimgapi.dll替换掉C:\Windows\System32\wimgapi.dll</code></pre><p>2.<a href="https://answers.microsoft.com/zh-hans/windows/forum/windows_10-update/win10%E9%87%8D%E7%BD%AE%E7%94%B5%E8%84%91%E6%97%B6/1e939a2d-a8c6-439f-9c45-b4bfdca78f32" target="_blank" rel="noopener">恢复出厂设置失败，window10 重置电脑未进行任何更改的问题</a></p><pre><code>记得以管理员权限运行cmd，命令copy即可，不要手动输入恢复出厂设置操作： “设置”-&gt;“恢复”-&gt;“重置此电脑（耗时1-2h）</code></pre><p>3.部分机型升级到win10后，无法直接恢复出厂设置</p><p>就只能用U盘了。可以用<a href="http://www.cfan.com.cn/2017/1026/129576.shtml" target="_blank" rel="noopener">系统自带磁盘管理</a>，开一个新的分区来安装win10，前提是U盘没有写入PE之类的东西</p><pre><code>1.压缩卷，用来分区 2.扩展卷，用来合并分区3.激活启动分区才能使用</code></pre><p>具体的过程就懒得写了。<br>注意以下几点：<br>1.先备份<br>2.安装的时候序列号不需要填<br>3.选择Windows10专业版<br><img src="http://upload-images.jianshu.io/upload_images/3117705-df293921168b75d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><pre><code>因为驱动器0是我自己的SSD ，驱动器1是机械硬盘，驱动器2是我的移动硬盘</code></pre><p>4.这一步的时候，把“驱动器为0”的都删了。选驱动器0进行安装，你们各自按照自己的来选择。</p><p>5.<img src="http://upload-images.jianshu.io/upload_images/3117705-1440a21ee459c294.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><pre><code>选择左下角 脱机用户就是创建本地用户，随便写个账号。</code></pre><p>6.装完了再把D盘的Drvceo驱动装一下就OK了，大功告成</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>无非就是备份，下载更新包，无脑下一步</p><p>中途出现的问题，直接Google就好了，一个个解决即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;老王: win10现在还免费吗?

  我: 免费的，免费的

老王: 升了到底有啥好处呢？

  我: 效率逼格就不说了，主要是默认保留原有文件和自带恢复出厂设置，以后就不需要为系统的事操心了。

老王: 真能保存之前文件吗？不影响吗？

  我: 是真的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Git命令整理</title>
    <link href="https://igding.github.io/2018/03/23/Git%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/"/>
    <id>https://igding.github.io/2018/03/23/Git命令整理/</id>
    <published>2018-03-23T13:03:53.578Z</published>
    <updated>2018-08-09T13:45:15.160Z</updated>
    
    <content type="html"><![CDATA[<p> <a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰Git学习链接</a></p><h2 id="1-安装-略"><a href="#1-安装-略" class="headerlink" title="1.安装(略)"></a>1.安装(略)</h2><h2 id="2-环境配置"><a href="#2-环境配置" class="headerlink" title="2.环境配置"></a>2.环境配置</h2><h6 id="a-git-config-–global-user-name-“Your-Name”"><a href="#a-git-config-–global-user-name-“Your-Name”" class="headerlink" title="a.  git config –global user.name “Your Name”"></a>a.  git config –global user.name “Your Name”</h6><h6 id="b-git-config-–global-user-email-“email-example-com“"><a href="#b-git-config-–global-user-email-“email-example-com“" class="headerlink" title="b.  git config –global user.email “email@example.com“"></a>b.  git config –global user.email “<a href="mailto:email@example.com" target="_blank" rel="noopener">email@example.com</a>“</h6><h6 id="c-ssh的绑定"><a href="#c-ssh的绑定" class="headerlink" title="c.  ssh的绑定"></a>c.  ssh的绑定</h6><p>windows的位置<br><img src="https://upload-images.jianshu.io/upload_images/3117705-638638f2880dd219.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>Mac的位置<br><img src="https://upload-images.jianshu.io/upload_images/3117705-309bca07ac6f7d61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h6 id="d-将id-rsa-pub的内容copy到对应平台“设置”中的ssh"><a href="#d-将id-rsa-pub的内容copy到对应平台“设置”中的ssh" class="headerlink" title="d.将id_rsa.pub的内容copy到对应平台“设置”中的ssh"></a>d.将id_rsa.pub的内容copy到对应平台“设置”中的ssh</h6><h2 id="3-项目的创建分两种情况"><a href="#3-项目的创建分两种情况" class="headerlink" title="3.项目的创建分两种情况"></a>3.项目的创建分两种情况</h2><h6 id="a-本地已创建，但是服务器没创建"><a href="#a-本地已创建，但是服务器没创建" class="headerlink" title="a.本地已创建，但是服务器没创建"></a>a.本地已创建，但是服务器没创建</h6><pre><code>1.在需要提交文件的地方 输入 git init2.服务器中创建项目， 3.用git命令去绑定url,命令：git remote add origin 加上ssh的链接</code></pre><p>必要情况下，强行塞进去<br>git push -u origin master -f<br>初次没啥问题，不过之后就要注意了</p><p><img src="https://upload-images.jianshu.io/upload_images/3117705-bde928b6527a8cfb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h6 id="b-服务器已创建-，但本地未创建"><a href="#b-服务器已创建-，但本地未创建" class="headerlink" title="b.服务器已创建 ，但本地未创建"></a>b.服务器已创建 ，但本地未创建</h6><p>git clone+ssh</p><h2 id="4-提交代码"><a href="#4-提交代码" class="headerlink" title="4.提交代码"></a>4.提交代码</h2><p>在“下载的项目”里面进行add commit 和push操作，项目外面不行</p><p><img src="https://upload-images.jianshu.io/upload_images/3117705-71a70976889e27b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/3117705-bafa9a3a9d05ac0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h6 id="错误示范，在项目外进行提交"><a href="#错误示范，在项目外进行提交" class="headerlink" title="错误示范，在项目外进行提交"></a>错误示范，在项目外进行提交</h6><p><img src="https://upload-images.jianshu.io/upload_images/3117705-d7aac4feee04cfea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>git branch -a  查看本地所有分支</p><p>git pull  拉取远程所有代码（只会拉取代码）</p><p>git fetch  拉取远程所有分支到本地<br><img src="https://upload-images.jianshu.io/upload_images/3117705-82dfd216c8ea37ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="只要remote下有分支就代表拉取成功"></p><p>git checkout xx(分支名)  切换分支 </p><pre><code>远程仓库必须要有改动，不然拉取是无效的。同时如果我已修改代码，同时想拉取别人已提交的代码，必须      先提交自己的代码再进行拉取</code></pre><p>git merge +指定分支    合并分支</p><p>git status 用于显示工作目录和暂存区的状态</p><p><img src="https://upload-images.jianshu.io/upload_images/3117705-e5aea00ac770b569.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>git reset –hard commit id(commit id 代表某个版本的id)   项目回滚</p><p>git log 去查询提交记录，包括commit id</p><p> git status 查看缓存区的状态(哪些已提交，哪些属于commit状态)<br>回滚之后提交代码，如果跟远程有冲突，要么下拉远程仓库代码解决冲突，要么 强行塞给远程分支(谨慎操作)</p><h2 id="项目常用套路："><a href="#项目常用套路：" class="headerlink" title="项目常用套路："></a>项目常用套路：</h2><h6 id="1-修改bug时"><a href="#1-修改bug时" class="headerlink" title="1. 修改bug时"></a>1. 修改bug时</h6><p>新建一个分支(例如 issue-101)，<br>创建分支，并切换git checkout -b issue-101<br>解决完删除新建的分支即可 git branch -d issue-101</p><h6 id="2-git怎么管理"><a href="#2-git怎么管理" class="headerlink" title="2.git怎么管理"></a>2.git怎么管理</h6><blockquote><p>a. master分支设置成保护状态(只能本人操作，其他人不可操作)<br>b. 分支个数=人数+2，”2”分别代表master和master的测试版</p></blockquote><h6 id="3-发布新版本"><a href="#3-发布新版本" class="headerlink" title="3.发布新版本"></a>3.发布新版本</h6><blockquote><p>a .git tag v1.0  在对应分支标记一个tag(因为每次要从id去找，太麻烦了)<br>b. 如果发布新版本忘记打标签了，可以用Git log 找到commit id<br>    输入 git tag v1.0  +commit id<br>c. 如果标签打错了，也可以删除  git tag -d v0.1<br>d. git tag查看所有标签<br>e. git show +标签名，可以得到commit id<br>f. 推送所有tag  git push origin –tags</p></blockquote><h6 id="4-原理"><a href="#4-原理" class="headerlink" title="4.原理"></a>4.原理</h6><p>只需要弄清楚基本原理，常用命令内部实际上在哪个区域干什么操作就行了。</p><p><img src="https://upload-images.jianshu.io/upload_images/3117705-7f69844d070ac2a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; &lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;廖雪峰Git学习链接&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>APP部分启动过程与Activity的生命周期调用过程</title>
    <link href="https://igding.github.io/2018/03/23/APP%E9%83%A8%E5%88%86%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E4%B8%8EActivity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B/"/>
    <id>https://igding.github.io/2018/03/23/APP部分启动过程与Activity的生命周期调用过程/</id>
    <published>2018-03-23T13:03:53.578Z</published>
    <updated>2018-06-19T08:57:59.628Z</updated>
    
    <content type="html"><![CDATA[<p>不擅长 长篇大论，直接以问题作为切入点来进行源码分析。</p><p>1.Java层的入口是main(),那么Android有没有main()？里面在做什么操作？<br>2.Android是如何启动的，Activity的生命周期是如何调用的？<br>3.setContentView究竟是在干什么？<br>4.view的绘制流程究竟是怎样的？<br>5.Zygote,Binder,Launcher,各种Manager等等都是些什么玩意…  <a href="https://blog.csdn.net/zhaokaiqiang1992/article/details/49428287#commentsedit" target="_blank" rel="noopener">参考链接</a><br>6.面试为什么总问这些问题？即便是懂了，之后也会忘，而且对应用层开发有什么实际性的帮助？<br>7.热修复，组件化，插件化等热门技术都要怎么搞？</p><p>1和2的答案：<br>Android应用程启动入口 ActivityThread的main()方法</p><pre><code>Looper.prepareMainLooper();//handler机制，ActivityThread thread = new ActivityThread();//实例化ResourcesManagerthread.attach(false);//****核心源码***** 最初的初始化Looper.loop();</code></pre><p>attach方法()核心源码分析<br>ViewRootImpl，Binder，暂时不分析，从ActivityManager开始</p><pre><code>private void attach(boolean system) {      final IActivityManager mgr = ActivityManager.getService();      try {          mgr.attachApplication(mAppThread);      } catch (RemoteException ex) {          throw ex.rethrowFromSystemServer();      }</code></pre><p>getService()源码分析<br>主要是用到单例，所有的类进入都会变成单例，这种设计模式暂时不分析，只需要知道，他是通过跨进程的方式来调用。</p><p>attachApplication在这里的作用其实实际上是将ActivityThread和ApplciationThread将其关联，把activity相关信息存储在applciationThread里面，apllicationThread的类为activity的各种状态做了相对应的准备工作</p><pre><code> public static IActivityManager getService() {    return IActivityManagerSingleton.get();}private static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =        new Singleton&lt;IActivityManager&gt;() {            @Override            protected IActivityManager create() {                final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);                final IActivityManager am = IActivityManager.Stub.asInterface(b);                return am;            }        };</code></pre><p>ActivityManager(app进程)和ActivityManagerService(系统进程)，通过binder机制，由系统来调用，不是自身来new Manager，而是系统来管理。实际上ActivityManager是有系统服务所调用管理，并且通过在binder接口当中进行调用，这也是可以解释为什么Activity是跨进程访问</p><p>那么为什么系统管理，而不是单独给他们配置呢？？</p><p>attachApplication(ApplicationThread)源码分析<br> 这里是一个接口，内部的Proxy中实现这个方法</p><pre><code>public interface IActivityManager extends IInterface {void attachApplication(IApplicationThread var1) throws RemoteException;//内部的Proxy实现了IActivityManagerprivate static class Proxy implements IActivityManager public void attachApplication(IApplicationThread app) throws RemoteException {            Parcel _data = Parcel.obtain();            Parcel _reply = Parcel.obtain();            try {                _data.writeInterfaceToken(&quot;android.app.IActivityManager&quot;);                _data.writeStrongBinder(app != null?app.asBinder():null);                this.mRemote.transact(11, _data, _reply, 0);                _reply.readException();            } finally {                _reply.recycle();                _data.recycle();            }        }private class ApplicationThread extends IApplicationThread.Stub ApplicationThread是继承了Stub,内部scheduleXXXActivity()函数，也就是说是在调用activity的生命周期。</code></pre><p>以最为典型的就是scheduleLaunchActivity() 启动activity</p><pre><code>   // we use token to identify this activity without having to send the    // activity itself back to the activity manager. (matters more with ipc)   @Override    public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident,            ActivityInfo info, Configuration curConfig, Configuration overrideConfig,            CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor,            int procState, Bundle state, PersistableBundle persistentState,            List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents,            boolean notResumed, boolean isForward, ProfilerInfo profilerInfo）      //实际上就是在这里创建的activity     ActivityClientRecord r = new ActivityClientRecord();      r.activityInfo = info;      //一大堆配置文件，省略      //H实际上就是一个handler        sendMessage(H.LAUNCH_ACTIVITY, r);    }//这里实际上就是用handler机制传递数据，那么就可以直接开始找handleMessage，看接收数据  private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) {    if (DEBUG_MESSAGES) Slog.v(        TAG, &quot;SCHEDULE &quot; + what + &quot; &quot; + mH.codeToString(what)        + &quot;: &quot; + arg1 + &quot; / &quot; + obj);    Message msg = Message.obtain();    msg.what = what;    msg.obj = obj;    msg.arg1 = arg1;    msg.arg2 = arg2;    if (async) {        msg.setAsynchronous(true);    }    mH.sendMessage(msg);}//这里暂时只分析activity部分，其他省略，很明显看的出来是在调用activity的生命周期。//我们只需要关注LAUNCH_ACTIVITY部分在做什么操作  public void handleMessage(Message msg) {        switch (msg.what) {            case LAUNCH_ACTIVITY: {            final ActivityClientRecord r = (ActivityClientRecord) msg.obj;             handleLaunchActivity(r, null, &quot;LAUNCH_ACTIVITY&quot;);                 break;            case RELAUNCH_ACTIVITY: {                ActivityClientRecord r = (ActivityClientRecord)msg.obj;                handleRelaunchActivity(r);                 break;            }            case PAUSE_ACTIVITY: {                handlePauseActivity();            }                   break;            case PAUSE_ACTIVITY_FINISHING: {                handlePauseActivity();            }                  break;            //略 //handleLaunchActivity源码分析 private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) {    //开启activity    Activity a = performLaunchActivity(r, customIntent);    handleResumeActivity(r.token, false, r.isForward,                !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);    }   if (a != null) {        r.createdConfig = new Configuration(mConfiguration);        reportSizeConfigurations(r);        Bundle oldState = r.state;      //resume方法        handleResumeActivity(r.token, false, r.isForward,                !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);        if (!r.activity.mFinished &amp;&amp; r.startsNotResumed) {          //pause方法            performPauseActivityIfNeeded(r, reason);private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {     ActivityInfo aInfo = r.activityInfo;    Activity activity = null;    try {  //  反射构建了一个activity        java.lang.ClassLoader cl = appContext.getClassLoader();        activity = mInstrumentation.newActivity(                cl, component.getClassName(), r.intent);           //调用了activity的attach()；            activity.attach();                //activity设置theme            activity.setTheme(theme);            if (r.isPersistable()) {              // 调用activity的onCreate()方法                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);            } else {                mInstrumentation.callActivityOnCreate(activity, r.state);            }           mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,                                r.persistentState);                    mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);    return activity;}</code></pre><blockquote><p>问题1和2的总结就是：当点击APP的时候，是由系统服务通过binder来调用，<br>    通过各种scheduXXXXXActivity()内部调用sendMessage，然后通过handler进行传递，根据不同的状态来进行调用不同的生命周期</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/3117705-42ceac08f7223bfc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>抄一波别人的图</p><p><img src="https://upload-images.jianshu.io/upload_images/3117705-82321614f3a0b47a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p>6的答案:组件化，插件化那些 就是模仿framework来的，热修复也是，都是模仿源码，从里面找灵感。<br>        架构师很多的设计思想都是通过源码中来的，当年的MVP是模仿Java GUI来的，所以 研究底层，就是为了做知识储备，发酵酝酿，就等你开窍，搞出个新东西出来，造福百姓。<br>        毕竟只会用三方库，写傻代码的猿肯定迟早会被淘汰的。获取别人的思想，当别人出现这样的业务场景时，Android底层是如何处理的</p></blockquote><p>核心还是binder和handler</p><p>下一篇文章将回答问题3，4，5，之后有时间会依次整理热修复 组件化和插件化源码分析。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不擅长 长篇大论，直接以问题作为切入点来进行源码分析。&lt;/p&gt;
&lt;p&gt;1.Java层的入口是main(),那么Android有没有main()？里面在做什么操作？&lt;br&gt;2.Android是如何启动的，Activity的生命周期是如何调用的？&lt;br&gt;3.setContent
      
    
    </summary>
    
    
  </entry>
  
</feed>
